import { join } from 'path';
import { isObject } from '@app-config/utils';
import { ParsedValue, FallbackSource, NotFoundError, WasNotObject, ReservedKeyError, } from '@app-config/core';
import { logger } from '@app-config/logging';
import { FileSource, FlexibleFileSource, defaultAliases, EnvironmentSource, asEnvOptions, currentEnvironment, } from '@app-config/node';
import { markAllValuesAsSecret } from '@app-config/extensions';
import { defaultExtensions, defaultEnvExtensions } from '@app-config/default-extensions';
import { loadSchema } from '@app-config/schema';
import { loadMetaConfig, loadExtraParsingExtensions } from '@app-config/meta';
export async function loadUnvalidatedConfig({ directory = '.', fileNameBase = '.app-config', secretsFileNameBase = `${fileNameBase}.secrets`, environmentVariableName = 'APP_CONFIG', extensionEnvironmentVariableNames = ['APP_CONFIG_EXTEND', 'APP_CONFIG_CI'], environmentOverride, environmentAliases: environmentAliasesArg, environmentSourceNames: environmentSourceNamesArg, parsingExtensions: parsingExtensionsArg, secretsFileExtensions: secretsFileExtensionsArg, environmentExtensions = defaultEnvExtensions(), defaultValues, } = {}) {
    var _a;
    // before trying to read .app-config files, we check for the APP_CONFIG environment variable
    const env = new EnvironmentSource(environmentVariableName);
    logger.verbose(`Trying to read ${environmentVariableName} for configuration`);
    try {
        let parsed = await env.read(environmentExtensions);
        if (defaultValues) {
            parsed = ParsedValue.merge(ParsedValue.literal(defaultValues), parsed);
        }
        verifyParsedValue(parsed);
        return {
            parsed,
            fullConfig: parsed.toJSON(),
            // NOTE: not checking meta values here
            environment: currentEnvironment(asEnvOptions(environmentOverride, environmentAliasesArg !== null && environmentAliasesArg !== void 0 ? environmentAliasesArg : defaultAliases, environmentSourceNamesArg)),
        };
    }
    catch (error) {
        // having no APP_CONFIG environment variable is normal, and should fall through to reading files
        if (!NotFoundError.isNotFoundError(error))
            throw error;
    }
    const meta = await loadMetaConfig({ directory });
    const environmentSourceNames = environmentSourceNamesArg !== null && environmentSourceNamesArg !== void 0 ? environmentSourceNamesArg : meta.value.environmentSourceNames;
    const environmentAliases = (_a = environmentAliasesArg !== null && environmentAliasesArg !== void 0 ? environmentAliasesArg : meta.value.environmentAliases) !== null && _a !== void 0 ? _a : defaultAliases;
    const environmentOptions = asEnvOptions(environmentOverride, environmentAliases, environmentSourceNames);
    const parsingExtensions = parsingExtensionsArg !== null && parsingExtensionsArg !== void 0 ? parsingExtensionsArg : defaultExtensions(environmentAliases, environmentOverride, undefined, environmentSourceNames);
    const secretsFileExtensions = secretsFileExtensionsArg !== null && secretsFileExtensionsArg !== void 0 ? secretsFileExtensionsArg : parsingExtensions.concat(markAllValuesAsSecret());
    logger.verbose(`Loading extra parsing extensions`);
    const extraParsingExtensions = await loadExtraParsingExtensions(meta);
    logger.verbose(`${extraParsingExtensions.length} user-defined parsing extensions found`);
    parsingExtensions.splice(0, 0, ...extraParsingExtensions);
    secretsFileExtensions.splice(0, 0, ...extraParsingExtensions);
    logger.verbose(`Trying to read files for configuration`);
    const [mainConfig, secrets] = await Promise.all([
        new FlexibleFileSource(join(directory, fileNameBase), undefined, environmentOptions).read(parsingExtensions),
        new FlexibleFileSource(join(directory, secretsFileNameBase), undefined, environmentOptions)
            .read(secretsFileExtensions)
            .catch((error) => {
            // NOTE: secrets are optional, so not finding them is normal
            if (NotFoundError.isNotFoundError(error, join(directory, secretsFileNameBase))) {
                logger.verbose('Did not find secrets file');
                return undefined;
            }
            throw error;
        }),
    ]);
    let parsed = secrets ? ParsedValue.merge(mainConfig, secrets) : mainConfig;
    if (defaultValues) {
        parsed = ParsedValue.merge(ParsedValue.literal(defaultValues), parsed);
    }
    // the APP_CONFIG_EXTEND and APP_CONFIG_CI can "extend" the config (override it), so it's done last
    if (extensionEnvironmentVariableNames.length > 0) {
        logger.verbose(`Checking [${extensionEnvironmentVariableNames.join(', ')}] for configuration extension`);
        const extension = new FallbackSource(extensionEnvironmentVariableNames.map((varName) => new EnvironmentSource(varName)));
        try {
            const parsedExtension = await extension.read(environmentExtensions);
            logger.verbose(`Found configuration extension in $${parsedExtension.assertSource(EnvironmentSource).variableName}`);
            parsed = ParsedValue.merge(parsed, parsedExtension);
        }
        catch (error) {
            // having no APP_CONFIG_CI environment variable is normal, and should fall through to reading files
            if (!NotFoundError.isNotFoundError(error))
                throw error;
        }
    }
    const filePaths = new Set();
    for (const source of mainConfig.allSources()) {
        if (source instanceof FileSource) {
            filePaths.add(source.filePath);
        }
    }
    if (secrets) {
        for (const source of secrets.allSources()) {
            if (source instanceof FileSource) {
                filePaths.add(source.filePath);
            }
        }
    }
    verifyParsedValue(parsed);
    return {
        parsed,
        parsedSecrets: secrets,
        parsedNonSecrets: mainConfig.cloneWhere((v) => !v.meta.fromSecrets),
        environment: currentEnvironment(environmentOptions),
        fullConfig: parsed.toJSON(),
        filePaths: Array.from(filePaths),
    };
}
export async function loadValidatedConfig(options, schemaOptions) {
    const [{ validate, validationFunctionCode, schema }, { fullConfig, parsed, ...rest }] = await Promise.all([
        loadSchema({
            directory: options === null || options === void 0 ? void 0 : options.directory,
            fileNameBase: (options === null || options === void 0 ? void 0 : options.fileNameBase) ? `${options.fileNameBase}.schema` : undefined,
            environmentVariableName: (options === null || options === void 0 ? void 0 : options.environmentVariableName)
                ? `${options.environmentVariableName}_SCHEMA`
                : undefined,
            environmentOverride: options === null || options === void 0 ? void 0 : options.environmentOverride,
            environmentAliases: options === null || options === void 0 ? void 0 : options.environmentAliases,
            environmentSourceNames: options === null || options === void 0 ? void 0 : options.environmentSourceNames,
            ...schemaOptions,
        }),
        loadUnvalidatedConfig(options),
    ]);
    if (!isObject(fullConfig)) {
        throw new WasNotObject('Configuration was not an object');
    }
    logger.verbose('Config was loaded, validating now');
    validate(fullConfig, parsed);
    return { fullConfig, parsed, schema, validationFunctionCode, ...rest };
}
function verifyParsedValue(parsed) {
    parsed.visitAll((value) => {
        var _a;
        for (const [key, item] of Object.entries((_a = value.asObject()) !== null && _a !== void 0 ? _a : {})) {
            if (key.startsWith('$') && !item.meta.fromEscapedDirective) {
                throw new ReservedKeyError(`Saw a '${key}' key in an object, which is a reserved key name. Please escape the '$' like '$${key}' if you intended to make this a literal object property.`);
            }
        }
    });
}
//# sourceMappingURL=index.js.map
import { extname } from 'path';
import { parse as parseTOML, stringify as stringifyTOML } from '@iarna/toml';
import { safeLoad as parseYAML, safeDump as stringifyYAML } from 'js-yaml';
import { parse as parseJSON5, stringify as stringifyJSON5 } from 'json5';
import { logger } from '@app-config/logging';
import { ParsedValue } from './parsed-value';
import { AppConfigError, NotFoundError, ParsingError, BadFileType, FallbackExhaustedError, } from './errors';
/**
 * File formats that app-config supports.
 */
export var FileType;
(function (FileType) {
    FileType["YAML"] = "YAML";
    FileType["TOML"] = "TOML";
    FileType["JSON"] = "JSON";
    FileType["JSON5"] = "JSON5";
    /** @hidden Raw is only used for CLI output */
    FileType["RAW"] = "RAW";
})(FileType || (FileType = {}));
/** Base class for "sources", which are strategies to read configuration (eg. files, environment variables) */
export class ConfigSource {
    /** Parses contents of the source */
    async readValue() {
        const [contents, fileType] = await this.readContents();
        return parseRawString(contents, fileType);
    }
    /** Reads the contents of the source into a full ParsedValue (not the raw JSON, like readValue) */
    async read(extensions, context) {
        const rawValue = await this.readValue();
        return ParsedValue.parse(rawValue, this, extensions, undefined, context);
    }
    /** Ergonomic helper for chaining `source.read(extensions).then(v => v.toJSON())` */
    async readToJSON(extensions, context) {
        const parsed = await this.read(extensions, context);
        return parsed.toJSON();
    }
}
/** Read configuration from a literal JS object */
export class LiteralSource extends ConfigSource {
    constructor(value) {
        super();
        this.value = value;
    }
    async readContents() {
        return [JSON.stringify(this.value), FileType.JSON];
    }
    async readValue() {
        return this.value; // overriden just for performance
    }
}
/** Read configuration from many ConfigSources and merge them */
export class CombinedSource extends ConfigSource {
    constructor(sources) {
        super();
        this.sources = sources;
        if (sources.length === 0) {
            throw new AppConfigError('CombinedSource requires at least one source');
        }
    }
    // overriden only because it's part of the class signature, normally would never be called
    async readContents() {
        const value = await this.readValue();
        return [JSON.stringify(value), FileType.JSON];
    }
    // override because readContents uses it (which is backwards from super class)
    async readValue() {
        return this.readToJSON();
    }
    // override so that ParsedValue is directly from the originating ConfigSource
    async read(extensions, context) {
        const values = await Promise.all(this.sources.map((source) => source.read(extensions, { ...context })));
        const merged = values.reduce((acc, parsed) => {
            if (!acc)
                return parsed;
            return ParsedValue.merge(acc, parsed);
        }, undefined);
        if (!merged)
            throw new AppConfigError('CombinedSource ended up merging into a falsey value');
        Object.assign(merged, { sources: [this] });
        return merged;
    }
}
/** Read configuration from the first ConfigSource that doesn't fail */
export class FallbackSource extends ConfigSource {
    constructor(sources) {
        super();
        this.sources = sources;
        if (sources.length === 0) {
            throw new AppConfigError('FallbackSource requires at least one source');
        }
    }
    // overriden only because it's part of the class signature, normally would never be called
    async readContents() {
        const value = await this.readValue();
        return [JSON.stringify(value), FileType.JSON];
    }
    // override because readContents uses it (which is backwards from super class)
    async readValue() {
        const errors = [];
        // take the first value that comes back without an error
        for (const source of this.sources) {
            try {
                const value = await source.readValue();
                logger.verbose(`FallbackSource found successful source`);
                return value;
            }
            catch (error) {
                if (source.filePath) {
                    // special case for ConfigSource with `filePath`, only accept a NotFoundError for it's filePath
                    if (NotFoundError.isNotFoundError(error, source.filePath)) {
                        errors.push(error);
                        continue;
                    }
                }
                else if (NotFoundError.isNotFoundError(error)) {
                    errors.push(error);
                    continue;
                }
                throw error;
            }
        }
        throw new FallbackExhaustedError('FallbackSource found no valid ConfigSource', errors);
    }
    // override so that ParsedValue is directly from the originating ConfigSource
    async read(extensions, context) {
        const errors = [];
        // take the first value that comes back without an error
        for (const source of this.sources) {
            try {
                const value = await source.read(extensions, context);
                logger.verbose(`FallbackSource found successful source`);
                return value;
            }
            catch (error) {
                if (source.filePath) {
                    // special case for ConfigSource with `filePath`, only accept a NotFoundError for it's filePath
                    if (NotFoundError.isNotFoundError(error, source.filePath)) {
                        errors.push(error);
                        continue;
                    }
                }
                else if (NotFoundError.isNotFoundError(error)) {
                    errors.push(error);
                    continue;
                }
                throw error;
            }
        }
        throw new FallbackExhaustedError('FallbackSource found no valid ConfigSource', errors);
    }
}
/**
 * Converts a JSON object to a string, using specified file type.
 */
export function stringify(config, fileType, minimal = false) {
    switch (fileType) {
        case FileType.JSON:
            return JSON.stringify(config, null, minimal ? 0 : 2);
        case FileType.JSON5:
            return stringifyJSON5(config, null, minimal ? 0 : 2);
        case FileType.TOML:
            return stringifyTOML(config);
        case FileType.YAML:
            return stringifyYAML(config);
        case FileType.RAW: {
            if (typeof config === 'string')
                return config;
            if (typeof config === 'number')
                return `${config}`;
            if (typeof config === 'boolean')
                return config ? 'true' : 'false';
            throw new BadFileType(`Stringifying "raw" only works with primitive values`);
        }
        default:
            throw new BadFileType(`Unsupported FileType '${fileType}'`);
    }
}
/**
 * Returns which file type to use, based on the file extension.
 */
export function filePathAssumedType(filePath) {
    switch (extname(filePath).toLowerCase().slice(1)) {
        case 'yml':
        case 'yaml':
            return FileType.YAML;
        case 'toml':
            return FileType.TOML;
        case 'json':
            return FileType.JSON;
        case 'json5':
            return FileType.JSON5;
        default:
            throw new BadFileType(`The file path "${filePath}" has an ambiguous file type, and a FileType could not be inferred`);
    }
}
/**
 * Parses string based on a file format.
 */
export async function parseRawString(contents, fileType) {
    var _a;
    switch (fileType) {
        case FileType.JSON:
            return JSON.parse(contents);
        case FileType.YAML:
            return ((_a = parseYAML(contents)) !== null && _a !== void 0 ? _a : {});
        case FileType.TOML:
            return parseTOML(contents);
        case FileType.JSON5:
            return parseJSON5(contents);
        default:
            throw new BadFileType(`Unsupported FileType '${fileType}'`);
    }
}
/**
 * Try to parse string as different file formats, returning the first that worked.
 */
export async function guessFileType(contents) {
    for (const tryType of [FileType.JSON, FileType.TOML, FileType.JSON5, FileType.YAML]) {
        try {
            await parseRawString(contents, tryType);
            return tryType;
        }
        catch {
            // parsing errors are expected
        }
    }
    throw new ParsingError(`The provided configuration was not in a detectable/parseable format`);
}
//# sourceMappingURL=config-source.js.map
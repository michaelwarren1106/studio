import { join, resolve } from 'path';
import { pathExists } from 'fs-extra';
import { FallbackSource, AppConfigError, FallbackExhaustedError, } from '@app-config/core';
import { logger } from '@app-config/logging';
import { FlexibleFileSource, FileSource } from '@app-config/node';
import { defaultMetaExtensions } from '@app-config/default-extensions';
export async function loadMetaConfig({ directory = '.', fileNameBase = '.app-config.meta', lookForWorkspace = '.git', } = {}) {
    let workspaceRoot = resolve(directory);
    // look upwards until a .git (workspace root) folder is found
    while (lookForWorkspace) {
        const parentDir = resolve(join(workspaceRoot, '..'));
        // we didn't find a .git root
        if (parentDir === workspaceRoot) {
            workspaceRoot = undefined;
            break;
        }
        workspaceRoot = parentDir;
        if (await pathExists(join(workspaceRoot, lookForWorkspace))) {
            break;
        }
    }
    // we try to find meta find in our CWD, but fallback to the workspace (git repo) root
    const sources = [new FlexibleFileSource(join(resolve(directory), fileNameBase))];
    if (workspaceRoot && workspaceRoot !== directory) {
        sources.push(new FlexibleFileSource(join(workspaceRoot, fileNameBase)));
    }
    const source = new FallbackSource(sources);
    try {
        const parsed = await source.read(defaultMetaExtensions());
        const value = parsed.toJSON();
        const fileSources = parsed.sources.filter((s) => s instanceof FileSource);
        const [{ filePath, fileType }] = fileSources.filter((s) => s.filePath.includes(fileNameBase));
        logger.verbose(`Meta file was loaded from ${filePath}`);
        return {
            filePath,
            fileType,
            value,
        };
    }
    catch (error) {
        if (error instanceof FallbackExhaustedError) {
            for (const { filepath } of error.errors) {
                if (sources.some((s) => s.filePath === filepath)) {
                    logger.verbose(`Meta file was not found in ${directory} or workspace root (${workspaceRoot !== null && workspaceRoot !== void 0 ? workspaceRoot : 'none'})`);
                    return { value: {} };
                }
            }
        }
        throw error;
    }
}
let metaConfig;
export async function loadMetaConfigLazy(options) {
    if (!metaConfig) {
        metaConfig = loadMetaConfig(options);
    }
    return metaConfig;
}
export async function loadExtraParsingExtensions({ value, }) {
    if (value.parsingExtensions) {
        return Promise.all(value.parsingExtensions.map(loadExtraParsingExtension));
    }
    return Promise.resolve([]);
}
export async function loadExtraParsingExtension(extensionConfig) {
    let name;
    let options;
    if (typeof extensionConfig === 'string') {
        name = extensionConfig;
    }
    else {
        ({ name, options } = extensionConfig);
    }
    logger.verbose(`Loading parsing extension: ${name}`);
    const loaded = (await import(name));
    if (typeof loaded === 'function') {
        return loaded(options);
    }
    if ('default' in loaded) {
        return loaded.default(options);
    }
    throw new AppConfigError(`Loaded parsing config module was invalid: ${name}`);
}
//# sourceMappingURL=index.js.map
import { logger } from '@app-config/logging';
/** Default aliases that app-config will resolve for you */
export const defaultAliases = {
    prod: 'production',
    dev: 'development',
};
/** Default environment variables that app-config will read */
export const defaultEnvVarNames = ['APP_CONFIG_ENV', 'NODE_ENV', 'ENV'];
/** Default options for {@link currentEnvironment} */
export const defaultEnvOptions = {
    aliases: defaultAliases,
    envVarNames: defaultEnvVarNames,
};
/** Conversion function useful for old usage of the deprecated {@link currentEnvironment} form */
export function asEnvOptions(override, aliases = defaultAliases, environmentSourceNames = defaultEnvVarNames) {
    return {
        override,
        aliases,
        envVarNames: typeof environmentSourceNames === 'string'
            ? [environmentSourceNames]
            : environmentSourceNames,
    };
}
export function currentEnvironment(...args) {
    var _a;
    let environmentSourceNames = defaultEnvVarNames;
    let environmentAliases = defaultAliases;
    let environmentOverride;
    if (args[0] &&
        typeof args[0] === 'object' &&
        ('override' in args[0] || 'aliases' in args[0] || 'envVarNames' in args[0])) {
        const options = args[0];
        if (options.override) {
            environmentOverride = options.override;
        }
        if (options.aliases) {
            environmentAliases = options.aliases;
        }
        if (options.envVarNames) {
            environmentSourceNames = options.envVarNames;
        }
    }
    else {
        if (args[0]) {
            environmentAliases = args[0];
            logger.warn('Detected deprecated usage of currentEnvironment');
        }
        if (Array.isArray(args[1])) {
            environmentSourceNames = args[1];
            logger.warn('Detected deprecated usage of currentEnvironment');
        }
        else if (typeof args[1] === 'string') {
            environmentSourceNames = [args[1]];
            logger.warn('Detected deprecated usage of currentEnvironment');
        }
    }
    if (environmentOverride) {
        if (environmentAliases[environmentOverride]) {
            return environmentAliases[environmentOverride];
        }
        return environmentOverride;
    }
    let value;
    for (const name of environmentSourceNames) {
        if ((_a = process.env[name]) === null || _a === void 0 ? void 0 : _a.length) {
            value = process.env[name];
            break;
        }
    }
    if (!value)
        return undefined;
    if (environmentAliases[value]) {
        return environmentAliases[value];
    }
    return value;
}
/** Reverse lookup of any aliases for some environment */
export function aliasesFor(env, aliases) {
    return Object.entries(aliases)
        .filter(([, value]) => value === env)
        .map(([key]) => key);
}
export function environmentOptionsFromContext(context) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return context.environmentOptions;
}
export function currentEnvFromContext(context, options) {
    const environmentOptions = environmentOptionsFromContext(context);
    if (environmentOptions) {
        return currentEnvironment(environmentOptions);
    }
    return currentEnvironment(options);
}
//# sourceMappingURL=environment.js.map
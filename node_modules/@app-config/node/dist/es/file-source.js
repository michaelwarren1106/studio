import { isAbsolute, join, dirname, resolve } from 'path';
import { readFile, pathExists } from 'fs-extra';
import { filePathAssumedType, ConfigSource, AppConfigError, NotFoundError, } from '@app-config/core';
import { logger } from '@app-config/logging';
import { aliasesFor, asEnvOptions, currentEnvFromContext, defaultEnvOptions, } from './environment';
/** Read configuration from a single file */
export class FileSource extends ConfigSource {
    constructor(filePath, fileType) {
        super();
        this.filePath = resolve(filePath);
        this.fileType = fileType !== null && fileType !== void 0 ? fileType : filePathAssumedType(this.filePath);
    }
    async readContents() {
        try {
            const content = await readFile(this.filePath);
            logger.verbose(`FileSource read ${this.filePath}`);
            return [content.toString('utf-8'), this.fileType];
        }
        catch (err) {
            if (err && typeof err === 'object' && err.code === 'ENOENT') {
                throw new NotFoundError(`File ${this.filePath} not found`, this.filePath);
            }
            throw err;
        }
    }
}
/** Read configuration from a file, found via "glob-like" search (any file format, with support for environment specific files) */
export class FlexibleFileSource extends ConfigSource {
    constructor(filePath, environmentOverrideOrFileExtensions, environmentAliasesOrEnvironmentOptions, fileExtensions, environmentSourceNames) {
        var _a;
        super();
        this.filePath = filePath;
        const defaultFileExtensions = ['yml', 'yaml', 'toml', 'json', 'json5'];
        if ((Array.isArray(environmentOverrideOrFileExtensions) ||
            environmentOverrideOrFileExtensions === undefined) &&
            (environmentAliasesOrEnvironmentOptions
                ? 'aliases' in environmentAliasesOrEnvironmentOptions ||
                    'envVarNames' in environmentAliasesOrEnvironmentOptions
                : true) &&
            fileExtensions === undefined &&
            environmentSourceNames === undefined) {
            this.fileExtensions = environmentOverrideOrFileExtensions !== null && environmentOverrideOrFileExtensions !== void 0 ? environmentOverrideOrFileExtensions : defaultFileExtensions;
            this.environmentOptions =
                (_a = environmentAliasesOrEnvironmentOptions) !== null && _a !== void 0 ? _a : defaultEnvOptions;
        }
        else {
            logger.warn(`Detected deprecated usage of FlexibleFileSource constructor loading ${filePath}`);
            this.fileExtensions = fileExtensions !== null && fileExtensions !== void 0 ? fileExtensions : defaultFileExtensions;
            this.environmentOptions = asEnvOptions(environmentOverrideOrFileExtensions, environmentAliasesOrEnvironmentOptions, environmentSourceNames);
        }
    }
    // share 'resolveSource' so that read() returns a ParsedValue pointed to the FileSource, not FlexibleFileSource
    async resolveSource(context) {
        const environment = currentEnvFromContext(context !== null && context !== void 0 ? context : {}, this.environmentOptions);
        const aliasesForCurrentEnv = environment
            ? aliasesFor(environment, this.environmentOptions.aliases)
            : [];
        const filesToTry = [];
        for (const ext of this.fileExtensions) {
            if (environment)
                filesToTry.push(`${this.filePath}.${environment}.${ext}`);
            for (const alias of aliasesForCurrentEnv) {
                filesToTry.push(`${this.filePath}.${alias}.${ext}`);
            }
        }
        // try these after trying environments, which take precedent
        for (const ext of this.fileExtensions) {
            filesToTry.push(`${this.filePath}.${ext}`);
        }
        logger.verbose(`FlexibleFileSource is trying to find [${filesToTry.join(', ')}]`);
        for (const filepath of filesToTry) {
            if (await pathExists(filepath)) {
                logger.verbose(`FlexibleFileSource found successful match at ${filepath}`);
                return new FileSource(filepath);
            }
        }
        throw new NotFoundError(`FlexibleFileSource could not find file with ${this.filePath}.{yml|yaml|toml|json|json5}`, this.filePath);
    }
    async readContents() {
        return this.resolveSource().then((source) => source.readContents());
    }
    async read(extensions, context) {
        const source = await this.resolveSource(context);
        return source.read(extensions, {
            ...context,
            environmentOptions: this.environmentOptions,
        });
    }
}
export function resolveFilepath(source, filepath) {
    let resolvedPath = filepath;
    // resolve filepaths that are relative to the current FileSource
    if (!isAbsolute(filepath) && source instanceof FileSource) {
        resolvedPath = join(dirname(source.filePath), filepath);
        if (resolve(source.filePath) === resolvedPath) {
            throw new AppConfigError(`An extension tried to resolve to it's own file (${resolvedPath}).`);
        }
    }
    return resolvedPath;
}
//# sourceMappingURL=file-source.js.map
/**
 * Type representing an optional value, like `foo?`.
 */
export declare type Option<T> = T | undefined;
export declare type Nullable<T> = T | null;
interface Ok<T> {
    ok: true;
    value: T;
}
interface Err<E> {
    ok: false;
    error: E;
}
/**
 * Sum type representing a successful result or failure.
 */
export declare type Result<T, E> = Ok<T> | Err<E>;
export declare function ok<T>(value: T): ResultExt<T, never>;
export declare function ok<T extends void | undefined | never>(): ResultExt<T, never>;
export declare function err<E>(error: E): ResultExt<never, E>;
export declare function err<E extends void | undefined | never>(): ResultExt<never, E>;
export declare type ResultExt<T, E> = Result<T, E> & {
    raw(): Result<T, E>;
    unwrap(): T;
    or<V, E2>(other: Result<V, E2>): ResultExt<T | V, E | E2>;
    orElse<V, E2>(other: () => Result<V, E2>): ResultExt<T | V, E | E2>;
    unwrapOr<V>(value: V): ResultExt<T | V, E>;
    unwrapOrElse<V>(value: () => V): ResultExt<T | V, E>;
    map<V>(map: (prev: T) => V): ResultExt<V, E>;
    mapErr<V>(map: (prev: E) => V): ResultExt<T, V>;
};
/**
 * Extends a Result with combinators.
 */
export declare const res: <T, E>(result: Result<T, E>) => ResultExt<T, E>;
/**
 * Merges two types, similar to a union but with the second type overriding the first type.
 */
export declare type Merge<FirstType, SecondType> = Omit<FirstType, Extract<keyof FirstType, keyof SecondType>> & SecondType;
/**
 * Returns the tuple of argument types of a function type.
 */
export declare type ArgumentTypes<T> = T extends (...args: infer U) => unknown ? U : never;
/**
 * Returns the argument of function T at position N.
 */
export declare type ArgumentType<T, N extends number> = ArgumentTypes<T>[N];
/**
 * For react components, gets the Props type.
 */
export declare type PropsType<T extends Function> = ArgumentType<T, 0>;
/**
 * Returns the return type of a function type.
 */
export declare type ReturnType<T> = T extends (...args: any) => infer R ? R : never;
/**
 * Changes the return type of a function type.
 */
export declare type ReplaceReturnType<T, R extends ReturnType<T>> = (...a: ArgumentTypes<T>) => R;
/**
 * Adds a `this` context to a function type.
 */
export declare type AddContext<T, TContext> = (this: TContext, ...a: ArgumentTypes<T>) => ReturnType<T>;
/**
 * Returns the value type that is resolved with `await T`
 */
export declare type Resolved<T> = T extends Promise<infer U> ? U : T;
/**
 * Returns the member type of an array.
 */
export declare type ArrayType<T> = T extends Array<infer V> ? V : never;
/**
 * An object with an indexing signature.
 */
export declare type Dictionary<V> = {
    [key: string]: V;
};
/**
 * Combines two booleans in generic.
 */
export declare type And<P1 extends boolean, P2 extends boolean> = P1 extends true ? P2 extends true ? true : false : false;
/**
 * Combines (OR) two booleans in generic.
 */
export declare type Or<P1 extends boolean, P2 extends boolean> = P1 extends true ? true : P2 extends true ? true : false;
/**
 * Combines (XOR) two booleans in generic.
 */
export declare type Xor<P1 extends boolean, P2 extends boolean> = P1 extends true ? P2 extends true ? false : true : P2 extends true ? true : false;
/**
 * Ensures V is assignable to T.
 */
export declare type Matches<V, T> = [V] extends [T] ? true : false;
/**
 * Ensures V is equal to T.
 */
export declare type Equal<V, T> = And<Matches<V, T>, Matches<T, V>>;
export interface JsonArray extends Array<Json> {
}
export interface JsonObject {
    [key: string]: Json | undefined;
}
/**
 * Type for any valid JSON file.
 */
export declare type Json = number | boolean | string | JsonArray | JsonObject | null;
/**
 * Get the types of values in an object
 */
export declare type ValuesOf<T> = T[keyof T];
/**
 * Ensures a class of type T.
 */
export declare type Class<T, A extends any[] = any[]> = new (...args: A) => T;
/**
 * Does the opposite of Partial<T>. Ensures the Keys values are non-optional.
 */
export declare type NonOptional<T, Key extends keyof T> = T & {
    [K in Key]-?: T[K];
};
/**
 * Makes all properties non-optional on a type.
 */
export declare type AllNonOptional<T> = NonOptional<T, keyof T>;
/**
 * Makes specific properties optional on a type.
 */
export declare type Optional<T, Key extends keyof T> = Merge<T, {
    [K in Key]?: T[K];
}>;
/**
 * Equivalent to Partial<T>, only here for consistency with Optional<T, Key>
 */
export declare type AllOptional<T> = Optional<T, keyof T>;
/**
 * Primitive (non-reference) javascript types.
 */
export declare type Primitive = string | number | boolean | undefined | null;
declare type DeepReadonlyObject<T> = {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};
/**
 * Makes all properties recursively ReadOnly.
 */
export declare type DeepReadonly<T> = T extends Primitive ? T : DeepReadonlyObject<T>;
export declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? DeepPartial<U>[] : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};
export interface IDisposable {
    dispose(): Promise<void> | void;
}
export declare function using<T extends IDisposable, U extends any>(resource: T, fn: (resource: T) => Promise<U> | U): Promise<U>;
export {};

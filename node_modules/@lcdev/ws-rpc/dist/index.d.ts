/// <reference types="node" />
import type { Server as HttpServer } from 'http';
import type { Server as HttpsServer } from 'https';
import type { Json } from '@lcdev/ts';
export { LogLevel, setLogLevel } from './logging';
export * from './errors';
export declare type FunctionName = string;
export declare type EventName = string;
/** Correlated types for a function/RPC call */
export declare type FunctionVariant<T extends FunctionName, Data extends Serializable | void = void, ResponseData extends Serializable | void = void, Serializable = never> = {
    request: {
        /** The FunctionName, which describes what kind of message it is */
        mt: T;
        /** A unique ID, to identify messages (to correspond request & response) */
        mid: string;
        /** What data comes with the message */
        data: Data;
    };
    response: {
        /** The FunctionName, which describes what kind of message it is */
        mt: T;
        /** A unique ID, to identify messages (to correspond request & response) */
        mid: string;
        /** What data comes back from the message */
        data: ResponseData;
    };
    error: {
        /** Marked for errors */
        err: true;
        /** A unique ID, to identify messages (to correspond request & response) */
        mid: string;
        /** Error description */
        message: string;
        /** Identifier of the error */
        code?: number | string;
        /** Any extra data attached to the error  */
        data?: Serializable;
    };
};
/** Correlated types for a bidirectional event */
export declare type EventVariant<T extends EventName, Data extends Serializable | void = void, Serializable = never> = {
    /** The EventName, which describes what kind of event it is */
    ev: T;
    /** The data associated with the event (can be void) */
    data: Data;
};
/** Canonical type representing all request -> response types (client to server) */
export declare type FunctionVariants<FunctionTypes extends FunctionName = never, Serializable = unknown> = {
    [T in FunctionTypes]: FunctionVariant<T, Serializable, Serializable, Serializable>;
};
/** Canonical type for all events that can occur (bidirectional) */
export declare type EventVariants<EventTypes extends EventName = never, Serializable = unknown> = {
    [T in EventTypes]: EventVariant<T, Serializable, Serializable>;
};
declare type AddFunctionVariant<Name extends FunctionName, RequestData extends Serializable | void, ResponseData extends Serializable | void, Serializable> = {
    [k in Name]: FunctionVariant<Name, RequestData, ResponseData, Serializable>;
};
declare type AddEventVariant<Name extends EventName, Data extends Serializable | void, Serializable> = {
    [k in Name]: EventVariant<Name, Data, Serializable>;
};
/** Callback returned that will cancel the registered listener */
export declare type CancelEventListener = () => void;
/** Common client/server functions to handle pub/sub of events */
export interface EventHandlers<Events extends EventVariants<EventName>> {
    /** Register an event handler */
    on<T extends keyof Events>(name: T, callback: (data: Events[T]['data']) => void): CancelEventListener;
    /** Register an event handler, only triggered once */
    once<T extends keyof Events>(name: T, callback: (data: Events[T]['data']) => void): CancelEventListener;
    /** Waits until an event is called once */
    one<T extends keyof Events>(name: T): Promise<Events[T]['data']>;
    /** Unregister an event handler */
    off<T extends keyof Events>(name: T, callback?: (data: Events[T]['data']) => void): void;
    /** Send an event to peer (server or client) */
    sendEvent<T extends keyof Events>(...args: Events[T]['data'] extends void ? [T] : [T, Events[T]['data']]): Promise<void>;
}
/** Callable function that proxies to a specific RPC call */
export declare type FunctionHandler<Function extends FunctionVariant<string, any, any, any>> = {
    (args: Function['request']['data'], timeoutMS?: number): Promise<Function['response']['data']>;
};
/** Callable functions that proxy to RPC calls. Available on client (calls server) and server (calls itself). */
export declare type FunctionHandlers<Functions extends FunctionVariants<FunctionName>> = {
    [F in keyof Functions]: FunctionHandler<Functions[F]>;
};
/** Common interface for websocket client (Browser, Node, etc), to avoid hard dependency on 'ws' library */
export interface WebSocketClient {
    binaryType?: string;
    readyState: number;
    addEventListener: {
        (method: 'open', cb: (event: {}) => void): void;
        (method: 'close', cb: (event: {
            code: number;
            reason: string;
        }) => void): void;
        (method: 'error', cb: (event: {
            error: any;
            message: any;
            type: string;
        }) => void): void;
        (method: 'message', cb: (event: {
            data: any;
            type: string;
        }) => void): void;
    };
    removeEventListener: {
        (method: 'open', cb: (event: {}) => void): void;
        (method: 'close', cb: (event: {
            code: number;
            reason: string;
        }) => void): void;
        (method: 'error', cb: (event: {
            error: any;
            message: any;
            type: string;
        }) => void): void;
        (method: 'message', cb: (event: {
            data: any;
            type: string;
        }) => void): void;
    };
    send(data: Serialized): void;
    close(): void;
}
/** Common interface for websocket server, to avoid hard dependency on 'ws' library */
export declare type WebSocketServer = WebSocketServerInner<'addListener', 'removeListener'> | WebSocketServerInner<'addEventListener', 'removeEventListener'> | WebSocketServerInner<'on', 'off'>;
declare type WebSocketServerInner<AddListener extends string, RemoveListener extends string> = {
    binaryType?: string;
    close(): void;
} & {
    [A in AddListener]: {
        (event: 'connection', cb: (connection: WebSocketClient) => void): void;
        (event: 'close', cb: () => void): void;
        (event: 'error', cb: (error: Error) => void): void;
    };
} & {
    [R in RemoveListener]: {
        (event: 'connection', cb: (connection: WebSocketClient) => void): void;
        (event: 'close', cb: () => void): void;
        (event: 'error', cb: (error: Error) => void): void;
    };
};
/** Common bidirectional type of a connected client or server (servers will call their own functions) */
export declare type Connection<Functions extends FunctionVariants<FunctionName>, Events extends EventVariants<EventName>> = EventHandlers<Events> & FunctionHandlers<Functions> & {
    ping(timeoutMS?: number): Promise<void>;
    onError(cb: (error: Error) => void): CancelEventListener;
    onClose(cb: () => void): CancelEventListener;
    isClosed(): boolean;
    close(): Promise<void>;
};
/** Configuration for using unix domain sockets */
export declare type UnixSocket = {
    socket: string;
};
/** Intermediate representation of a client type, that can connect to a server */
export declare type Client<Functions extends FunctionVariants<FunctionName>, Events extends EventVariants<EventName>> = {
    connect(port: number, secure?: boolean): Promise<Connection<Functions, Events>>;
    connect(host: string, port: number, secure?: boolean): Promise<Connection<Functions, Events>>;
    connect(socket: UnixSocket): Promise<Connection<Functions, Events>>;
    connect(client: WebSocketClient): Promise<Connection<Functions, Events>>;
};
/** Intermediate representation of a server type, that can listen for connections */
export declare type Server<Functions extends FunctionVariants, Events extends EventVariants> = {
    listen(port: number): Promise<Connection<Functions, Events>>;
    listen(host: string, port: number): Promise<Connection<Functions, Events>>;
    listen(socket: UnixSocket): Promise<Connection<Functions, Events>>;
    listen(server: WebSocketServer): Promise<Connection<Functions, Events>>;
    listen(server: HttpServer): Promise<Connection<Functions, Events>>;
    listen(server: HttpsServer): Promise<Connection<Functions, Events>>;
};
/** Data type across the wire */
export declare type Serialized = string | ArrayBuffer;
/** Abstraction for data serialization (JSON, BSON, etc.) */
export interface DataSerialization<Serializable> {
    serialize(data: Serializable): Serialized | Promise<Serialized>;
    deserialize(data: Serialized): Serializable | Promise<Serializable>;
}
/** Basic JSON wire format (de)serialization */
export declare const jsonSerialization: DataSerialization<Json>;
/** Function that validates incoming or outgoing data */
export declare type ValidationFunction<Data> = (data: Data) => (Error & {
    code?: number | string;
}) | false;
/** Common isomorphic builder type for a Client/Server pair */
export declare type Builder<Serializable, Functions extends FunctionVariants<FunctionName, Serializable> = FunctionVariants<never, Serializable>, Events extends EventVariants<EventName, Serializable> = EventVariants<never, Serializable>> = {
    /** Adds a function type that can be called. Request validation is optional. */
    func: {
        <Name extends FunctionName = never, Request extends Serializable | void = void, Response extends Serializable | void = void>(): Builder<Serializable, Functions & AddFunctionVariant<Name, Request, Response, Serializable>, Events>;
        <Name extends FunctionName = never, Request extends Serializable | void = void, Response extends Serializable | void = void>(name: Name, validation: ValidationFunction<Request>): Builder<Serializable, Functions & AddFunctionVariant<Name, Request, Response, Serializable>, Events>;
    };
    /** Adds an event type that can be triggered from either side. Data validation is optional. */
    event: {
        <Name extends EventName = never, Data extends Serializable | void = void>(): Builder<Serializable, Functions, Events & AddEventVariant<Name, Data, Serializable>>;
        <Name extends EventName = never, Data extends Serializable | void = void>(name: Name, validation: ValidationFunction<Data>): Builder<Serializable, Functions, Events & AddEventVariant<Name, Data, Serializable>>;
    };
    /** Create a client with the built up types */
    client(shouldValidate?: boolean): Client<Functions, Events>;
    /** Create a server with the built up types */
    server(handlers: FunctionHandlers<Functions>, shouldValidate?: boolean): Server<Functions, Events>;
    /** Associated type representing the client() return value */
    Client: Client<Functions, Events>;
    /** Associated type representing the server() return value */
    Server: Server<Functions, Events>;
    /** Associated type representing a connected client or server */
    Connection: Connection<Functions, Events>;
    /** Associated type representing FunctionVariants */
    Functions: Functions;
    /** Associated type representing EventVariants */
    Events: Events;
    /** Associated type representing server function handlers */
    FunctionHandlers: FunctionHandlers<Functions>;
};
/** Builder for Client/Server pair */
export declare function build<Serializable>(serializer: DataSerialization<Serializable>): Builder<Serializable>;

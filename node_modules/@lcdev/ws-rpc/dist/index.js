"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.jsonSerialization = void 0;
const nanoid_1 = require("nanoid");
const logging_1 = require("./logging");
const errors_1 = require("./errors");
var logging_2 = require("./logging");
Object.defineProperty(exports, "LogLevel", { enumerable: true, get: function () { return logging_2.LogLevel; } });
Object.defineProperty(exports, "setLogLevel", { enumerable: true, get: function () { return logging_2.setLogLevel; } });
__exportStar(require("./errors"), exports);
/** Basic JSON wire format (de)serialization */
exports.jsonSerialization = {
    serialize: JSON.stringify,
    deserialize: JSON.parse,
};
/** Builder for Client/Server pair */
function build(serializer) {
    return buildInner({}, {});
    function buildInner(functionValidation, eventValidation) {
        return {
            // Associated types, only for Typescript
            Client: undefined,
            Server: undefined,
            Connection: undefined,
            Functions: undefined,
            Events: undefined,
            FunctionHandlers: undefined,
            func(name, validation) {
                if (!name || !validation) {
                    return buildInner(functionValidation, eventValidation);
                }
                if (functionValidation[name]) {
                    throw new errors_1.RpcError(`Tried to call func() with validation, but a function named ${name} already exists.`, errors_1.ErrorType.BuildError);
                }
                return buildInner(Object.assign(Object.assign({}, functionValidation), { [name]: validation }), eventValidation);
            },
            event(name, validation) {
                if (!name || !validation) {
                    return buildInner(functionValidation, eventValidation);
                }
                if (eventValidation[name]) {
                    throw new errors_1.RpcError(`Tried to call event() with validation, but an event named ${name} already exists.`, errors_1.ErrorType.BuildError);
                }
                return buildInner(functionValidation, Object.assign(Object.assign({}, eventValidation), { [name]: validation }));
            },
            // build up a Client type that'll connect lazily
            client(shouldValidate = true) {
                if (shouldValidate) {
                    logging_1.logger.verbose(`Setting up a Client that should validate data`);
                }
                else {
                    logging_1.logger.verbose(`Setting up a Client that should not validate data`);
                }
                async function connect(...args) {
                    let connection;
                    // see the Client::connect function for all overload types
                    if (typeof args[0] === 'number') {
                        const [port, secure] = args;
                        return connect('127.0.0.1', port, secure);
                    }
                    if (args[0] && typeof args[0] === 'object' && 'socket' in args[0]) {
                        const [{ socket }] = args;
                        const WebSocket = await getWebSocket();
                        logging_1.logger.info(`Connecting to 'ws+unix://${socket}'`);
                        connection = new WebSocket(`ws+unix://${socket}`);
                    }
                    else if (typeof args[0] === 'string') {
                        const [host, port, secure] = args;
                        const WebSocket = await getWebSocket();
                        if (secure === true) {
                            logging_1.logger.info(`Connecting to 'wss://${host}:${port}'`);
                            connection = new WebSocket(`wss://${host}:${port}`);
                        }
                        else {
                            logging_1.logger.info(`Connecting to 'ws://${host}:${port}'`);
                            connection = new WebSocket(`ws://${host}:${port}`);
                        }
                    }
                    else {
                        const [client] = args;
                        logging_1.logger.info(`Connecting using a provided WebSocket`);
                        connection = client;
                    }
                    const [timeout, clearTimeout] = createTimeout(10000, new errors_1.RpcError('Connecting to WebSocket server timed out', errors_1.ErrorType.Timeout));
                    const connecting = new Promise((resolve, reject) => {
                        connection.addEventListener('open', () => resolve());
                        connection.addEventListener('error', (err) => reject(err));
                    });
                    await Promise.race([connecting, timeout]).finally(clearTimeout);
                    logging_1.logger.info(`WebSocket client connection opened`);
                    return setupClient(connection, serializer, functionValidation, eventValidation, shouldValidate);
                }
                return { connect };
            },
            // build up a Server type that'll listen lazily
            server(handlers, shouldValidate = true) {
                if (shouldValidate) {
                    logging_1.logger.verbose(`Setting up a Server that should validate data`);
                }
                else {
                    logging_1.logger.verbose(`Setting up a Server that should not validate data`);
                }
                async function listen(...args) {
                    let connection;
                    // we need the inner type, so that an explicit HTTP server is closed as well
                    let inner;
                    // see the Server::listen function for overloads
                    if (args[0] && typeof args[0] === 'object' && 'socket' in args[0]) {
                        const { Server } = await Promise.resolve().then(() => __importStar(require('http')));
                        const [{ socket }] = args;
                        const server = new Server();
                        server.listen(socket);
                        return listen(server);
                    }
                    if (typeof args[0] === 'number') {
                        const [port] = args;
                        const { Server: WebSocketServer } = await Promise.resolve().then(() => __importStar(require('ws')));
                        logging_1.logger.info(`Creating a WebSocket server on localhost:${port}`);
                        connection = new WebSocketServer({ port });
                    }
                    else if (typeof args[0] === 'string') {
                        const [host, port] = args;
                        const { Server: WebSocketServer } = await Promise.resolve().then(() => __importStar(require('ws')));
                        logging_1.logger.info(`Creating a WebSocket server on ${host}:${port}`);
                        connection = new WebSocketServer({ host, port });
                    }
                    else if (args[0] instanceof (await Promise.resolve().then(() => __importStar(require('http')))).Server) {
                        const { Server: WebSocketServer } = await Promise.resolve().then(() => __importStar(require('ws')));
                        logging_1.logger.info(`Creating a WebSocket server with a HTTP server`);
                        const [server] = args;
                        inner = server;
                        connection = new WebSocketServer({ server });
                    }
                    else if (args[0] instanceof (await Promise.resolve().then(() => __importStar(require('https')))).Server) {
                        const { Server: WebSocketServer } = await Promise.resolve().then(() => __importStar(require('ws')));
                        logging_1.logger.info(`Creating a WebSocket server with a HTTPS server`);
                        const [server] = args;
                        inner = server;
                        connection = new WebSocketServer({ server });
                    }
                    else {
                        [connection] = args;
                    }
                    return setupServer(connection, inner, handlers, serializer, functionValidation, eventValidation, shouldValidate);
                }
                return { listen };
            },
        };
    }
}
exports.build = build;
function setupClient(conn, { deserialize, serialize }, functionValidation, eventValidation, shouldValidate) {
    if ('binaryType' in conn) {
        conn.binaryType = 'arraybuffer';
    }
    const on = conn.addEventListener.bind(conn);
    const off = conn.removeEventListener.bind(conn);
    on('message', messageHandler);
    on('open', () => {
        logging_1.logger.info(`Open event triggered: re-registering message handlers`);
        // re-register the message handler every 'open' event
        off('message', messageHandler);
        on('message', messageHandler);
    });
    // client state
    const waitingForResponse = new Map();
    const connectionHandling = setupConnectionEventHandling(on);
    const eventHandling = setupEventHandling(eventValidation, shouldValidate);
    function assertConnectionOpen() {
        switch (conn.readyState) {
            case 1:
                return;
            case 0:
                throw new errors_1.RpcError('WebSocket connection is CONNECTING, cannot perform operation', errors_1.ErrorType.ConnectionNotOpen);
            case 2:
                throw new errors_1.RpcError('WebSocket connection is CLOSING, cannot perform operation', errors_1.ErrorType.ConnectionNotOpen);
            default:
                throw new errors_1.RpcError('WebSocket connection is CLOSED, cannot perform operation', errors_1.ErrorType.ConnectionNotOpen);
        }
    }
    async function messageHandler({ data: msg }) {
        if (msg === 'ping') {
            logging_1.logger.verbose('Received a ping! Responding with pong.');
            conn.send('pong');
            return;
        }
        const parsed = (await deserialize(msg));
        if (typeof parsed !== 'object' || parsed === null) {
            logging_1.logger.warn(`Received an unexpected message - deserialized as non-object. (${parsed})`);
            return;
        }
        if ('err' in parsed) {
            const { message, code, data, mid: messageID } = parsed;
            const error = Object.assign(new errors_1.RpcError(message, code ? code : errors_1.ErrorType.Response), { code, data });
            const respond = waitingForResponse.get(messageID);
            waitingForResponse.delete(messageID);
            if (respond) {
                respond(Promise.reject(error));
            }
            else {
                logging_1.logger.warn(`Received an error response for a message we did not anticipate.`);
            }
        }
        else if ('mt' in parsed) {
            const { mt, mid: messageID, data } = parsed;
            const respond = waitingForResponse.get(messageID);
            waitingForResponse.delete(messageID);
            if (shouldValidate && functionValidation[mt] && respond) {
                const error = functionValidation[mt];
                if (error) {
                    respond(Promise.reject(error));
                    return;
                }
            }
            if (respond) {
                respond(Promise.resolve(data));
            }
            else {
                logging_1.logger.warn(`Received a success response for a message we did not anticipate.`);
            }
        }
        else if ('ev' in parsed) {
            eventHandling.dispatch(parsed);
        }
    }
    return new Proxy({}, {
        get(_, prop) {
            switch (prop) {
                case 'on':
                case 'once':
                case 'one':
                case 'off':
                    return eventHandling[prop];
                case 'onError':
                case 'onClose':
                    return connectionHandling[prop];
                case 'sendEvent':
                    return async (name, data) => {
                        assertConnectionOpen();
                        if (shouldValidate && eventValidation[name]) {
                            const error = eventValidation[name](data);
                            if (error) {
                                throw error;
                            }
                        }
                        logging_1.logger.verbose(`Sending an event '${name}'`);
                        conn.send(await serialize({ ev: name, data }));
                    };
                case 'isClosed':
                    return () => {
                        return conn.readyState === 2 || conn.readyState === 3;
                    };
                case 'close':
                    return async () => {
                        // TODO: wait for events to propogate and responses to come in
                        switch (conn.readyState) {
                            case 0:
                            case 1: {
                                logging_1.logger.verbose(`Closing connection`);
                                conn.close();
                                break;
                            }
                            default: {
                                logging_1.logger.warn(`Connection was already closed, closing anyway`);
                                conn.close();
                                break;
                            }
                        }
                    };
                case 'then':
                    return undefined;
                case 'ping': // ping is just a builtin function type
                default: {
                    if (typeof prop !== 'string')
                        return undefined;
                    // all function calls go through here, it's why we set up a Proxy
                    return async (data, timeoutMS = 15000) => {
                        var _a;
                        assertConnectionOpen();
                        const message = { mt: prop, data, mid: nanoid_1.nanoid() };
                        if (prop === 'ping') {
                            // ping(timeoutMS)
                            timeoutMS = (_a = data) !== null && _a !== void 0 ? _a : 500;
                            data = undefined;
                        }
                        if (shouldValidate && functionValidation[prop]) {
                            const error = functionValidation[prop](data);
                            if (error) {
                                throw error;
                            }
                        }
                        logging_1.logger.verbose(`Calling remote function: ${prop} (messageID: ${message.mid})`);
                        const response = new Promise((resolve, reject) => {
                            waitingForResponse.set(message.mid, (respond) => respond.then(resolve, reject));
                        });
                        conn.send(await serialize(message));
                        const [timeout, clearTimeout] = createTimeout(timeoutMS, new errors_1.RpcError(`Call to '${prop}' failed because it timed out in ${timeoutMS}ms`, errors_1.ErrorType.Timeout));
                        return Promise.race([
                            response,
                            timeout.then(() => waitingForResponse.delete(message.mid)),
                        ]).finally(clearTimeout);
                    };
                }
            }
        },
    });
}
function setupServer(conn, inner, handlers, { deserialize, serialize }, functionValidation, eventValidation, shouldValidate) {
    if ('binaryType' in conn) {
        conn.binaryType = 'arraybuffer';
    }
    let on;
    if ('on' in conn) {
        on = conn.on.bind(conn);
    }
    else if ('addEventListener' in conn) {
        on = conn.addEventListener.bind(conn);
    }
    else if ('addListener' in conn) {
        on = conn.addListener.bind(conn);
    }
    else {
        throw new errors_1.RpcError('WebSocketServer did not have event bindings', errors_1.ErrorType.InvalidWebsocket);
    }
    const activeConnections = new Set();
    on('connection', (client) => {
        logging_1.logger.info(`A new client has connected!`);
        activeConnections.add(client);
        client.addEventListener('close', () => activeConnections.delete(client));
        client.addEventListener('message', messageHandler(client));
    });
    // server state
    const eventHandling = setupEventHandling(eventValidation, shouldValidate);
    const connectionHandling = setupConnectionEventHandling(on);
    const incomingPongListeners = new Set();
    let isClosed = false;
    function messageHandler(client) {
        return async ({ data: msg }) => {
            if (msg === 'pong') {
                logging_1.logger.verbose('Received a pong response!');
                for (const notify of incomingPongListeners) {
                    notify(client);
                }
                return;
            }
            const parsed = (await deserialize(msg));
            if (typeof parsed !== 'object' || parsed === null) {
                return;
            }
            if ('err' in parsed) {
                logging_1.logger.warn(`Received an 'err' message, which clients should not send.`);
            }
            else if ('ev' in parsed) {
                logging_1.logger.verbose(`Received a '${parsed.ev}' event`);
                eventHandling.dispatch(parsed);
            }
            else if ('mt' in parsed) {
                const { mt, mid, data } = parsed;
                if (mt === 'ping') {
                    client.send(await serialize({ mt, mid }));
                    return;
                }
                if (!handlers[mt]) {
                    logging_1.logger.error(`A function '${mt}' was attempted, but we had no valid handlers`);
                    client.send(await serialize({
                        mid,
                        err: true,
                        message: `Server had no registered handler for function '${mt}'`,
                    }));
                    return;
                }
                if (shouldValidate && functionValidation[mt]) {
                    const error = functionValidation[mt](data);
                    if (error) {
                        client.send(await serialize({ mid, err: true, message: error.message, code: error.code }));
                        return;
                    }
                }
                logging_1.logger.verbose(`Function '${mt}' was called`);
                await handlers[mt](data).then(async (response) => {
                    client.send(await serialize({ mt, mid, data: response }));
                }, async (error) => {
                    client.send(await serialize({ mid, err: true, message: error.message, code: error.code }));
                });
            }
        };
    }
    return new Proxy({}, {
        get(_, prop) {
            switch (prop) {
                case 'on':
                case 'once':
                case 'one':
                case 'off':
                    return eventHandling[prop];
                case 'onError':
                case 'onClose':
                    return connectionHandling[prop];
                case 'sendEvent':
                    return async (name, data) => {
                        if (shouldValidate && eventValidation[name]) {
                            const error = eventValidation[name](data);
                            if (error) {
                                throw error;
                            }
                        }
                        logging_1.logger.verbose(`Sending an event '${name}'`);
                        const message = await serialize({ ev: name, data });
                        for (const client of activeConnections) {
                            try {
                                client.send(message);
                            }
                            catch (err) {
                                logging_1.logger.error(`Failed to send event to a client: ${normalizeError(err).toString()}`);
                            }
                        }
                    };
                case 'ping':
                    return async (timeoutMS = 200) => {
                        const waitingFor = new Set(activeConnections);
                        logging_1.logger.verbose(`Pinging ${waitingFor.size} connected clients`);
                        for (const client of waitingFor) {
                            client.send('ping');
                        }
                        const waitForPongs = new Promise((resolve) => {
                            const listenForPongs = (client) => {
                                waitingFor.delete(client);
                                if (waitingFor.size === 0) {
                                    incomingPongListeners.delete(listenForPongs);
                                    resolve();
                                }
                            };
                            incomingPongListeners.add(listenForPongs);
                        });
                        const [timeout, clearTimeout] = createTimeout(timeoutMS, new errors_1.RpcError(`Pinging all clients exceeded timeout ${timeoutMS}ms`, errors_1.ErrorType.Timeout));
                        await Promise.race([waitForPongs, timeout]).finally(clearTimeout);
                    };
                case 'isClosed':
                    return () => {
                        return isClosed;
                    };
                case 'close':
                    return async () => {
                        // TODO: wait for events to propogate and responses to be sent
                        logging_1.logger.verbose(`Closing connection`);
                        isClosed = true;
                        conn.close();
                        if (inner) {
                            await new Promise((resolve, reject) => {
                                inner.close((err) => {
                                    if (err)
                                        reject(err);
                                    else
                                        resolve();
                                });
                            });
                        }
                    };
                case 'then':
                    return undefined;
                default: {
                    if (typeof prop !== 'string')
                        return undefined;
                    // a server calls itself
                    const handler = handlers[prop];
                    return async (data, timeoutMS = 15000) => {
                        if (shouldValidate && functionValidation[prop]) {
                            const error = functionValidation[prop](data);
                            if (error) {
                                throw error;
                            }
                        }
                        const response = handler(data);
                        const [timeout, clearTimeout] = createTimeout(timeoutMS, new errors_1.RpcError(`Call to '${prop}' failed because it timed out in ${timeoutMS}ms`, errors_1.ErrorType.Timeout));
                        return Promise.race([response, timeout]).finally(clearTimeout);
                    };
                }
            }
        },
    });
}
function setupConnectionEventHandling(on) {
    const onClose = new Set();
    const onError = new Set();
    on('close', () => {
        if (onClose.size === 0) {
            logging_1.logger.warn('Connection was closed');
        }
        for (const callback of onClose) {
            callback();
        }
    });
    on('error', (error) => {
        const normalized = normalizeError(error);
        if (onError.size === 0) {
            logging_1.logger.warn(`Connection error: ${normalized.toString()}`);
        }
        for (const callback of onError) {
            callback(normalized);
        }
    });
    return {
        onClose(cb) {
            onClose.add(cb);
            return () => onClose.delete(cb);
        },
        onError(cb) {
            onError.add(cb);
            return () => onError.delete(cb);
        },
    };
}
function setupEventHandling(eventValidation, shouldValidate) {
    const eventHandlers = new Map();
    function dispatch(parsed) {
        var _a;
        const { ev: eventType, data } = parsed;
        const handlers = (_a = eventHandlers.get(eventType)) !== null && _a !== void 0 ? _a : [];
        if (shouldValidate && eventValidation[eventType]) {
            const error = eventValidation[eventType](data);
            if (error) {
                throw error;
            }
        }
        for (const handler of handlers) {
            try {
                handler(data);
            }
            catch (error) {
                logging_1.logger.error(`An event handler for ${eventType} failed: ${normalizeError(error).toString()}`);
            }
        }
    }
    function on(name, callback) {
        if (!eventHandlers.has(name)) {
            eventHandlers.set(name, new Set());
        }
        eventHandlers.get(name).add(callback);
        return () => off(name, callback);
    }
    function once(name, callback) {
        on(name, Object.assign(callback, { once: true }));
        return () => off(name, callback);
    }
    function one(name) {
        return new Promise((resolve) => once(name, resolve));
    }
    function off(name, callback) {
        var _a, _b;
        if (callback) {
            (_a = eventHandlers.get(name)) === null || _a === void 0 ? void 0 : _a.delete(callback);
        }
        else {
            (_b = eventHandlers.get(name)) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    return {
        on,
        once,
        one,
        off,
        dispatch,
    };
}
function createTimeout(ms, error) {
    let timeoutId;
    const promise = new Promise((_, reject) => {
        timeoutId = setTimeout(() => {
            reject(error);
        }, ms);
    });
    return [
        promise,
        () => {
            clearTimeout(timeoutId);
        },
    ];
}
function normalizeError(error) {
    var _a, _b;
    let normalized;
    if (error instanceof Error) {
        normalized = error;
    }
    else if (typeof error !== 'object' || error === null) {
        normalized = new errors_1.RpcError(`Unknown error: ${(_a = error) === null || _a === void 0 ? void 0 : _a.toString()}`, errors_1.ErrorType.Unknown);
    }
    else if ('error' in error && error.error instanceof Error) {
        normalized = error.error;
    }
    else {
        normalized = new errors_1.RpcError(`Unknown error: ${(_b = error) === null || _b === void 0 ? void 0 : _b.toString()}`, errors_1.ErrorType.Unknown);
    }
    return normalized;
}
// resolve to the WebSocket client library - use the global and avoid 'ws' if possible
function getWebSocket() {
    if (typeof globalThis !== 'undefined' && 'WebSocket' in globalThis) {
        return Promise.resolve(globalThis.WebSocket);
    }
    if (typeof window !== 'undefined' && 'WebSocket' in window) {
        return Promise.resolve(window.WebSocket);
    }
    if (typeof global !== 'undefined' && 'WebSocket' in global) {
        return Promise.resolve(global.WebSocket);
    }
    return Promise.resolve().then(() => __importStar(require('ws'))).then((ws) => ws.default);
}
// ts assertions to ensure compatibility
/* eslint-disable */
const _test1 = null;
const _test2 = null;
const _test3 = null;
const _test4 = null;
//# sourceMappingURL=index.js.map
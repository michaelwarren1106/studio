import * as Ajv from "ajv";
import { JsonSchemaType } from "./JsonSchemaType";
import { Combine, DeepPartial, Merge, Overwrite, PartialProperties, Rename, RequiredProperties, TransformProperties, TransformPropertiesToArray, UnwrapArrayProperties, Nullable, OneOf, AllOf, RequiredKnownKeys, OptionalKnownKeys, KnownKeys } from "./TransformationTypes";
import { JSONSchema } from "./JsonSchema";
/**
 * Represents a JSON Schema and its type.
 */
export declare class SchemaBuilder<T> {
    protected schemaObject: JSONSchema;
    protected validationConfig?: Ajv.Options | undefined;
    /**
     * Get the JSON schema object
     */
    get schema(): JSONSchema;
    /**
     * Initialize a new SchemaBuilder instance.
     * /!\ schemaObject must not contain references. If you have references, use something like json-schema-ref-parser library first.
     */
    constructor(schemaObject: JSONSchema, validationConfig?: Ajv.Options | undefined);
    /**
     * Function that take an inline JSON schema and deduces its type automatically!
     * Type, enums and required have to be string literals for this function to work... So you'll probably have to use contants (ex: STRING_TYPE), use the helper 'keys' function or pass the schema itself as the generic type argument.
     */
    static fromJsonSchema<S>(schema: S, validationConfig?: Ajv.Options): SchemaBuilder<JsonSchemaType<S>>;
    /**
     * Create an empty object schema
     * AdditionalProperties is automatically set to false
     */
    static emptySchema<N extends boolean = false>(schema?: Pick<JSONSchema, JSONSchemaObjectProperties>, nullable?: N): N extends true ? SchemaBuilder<{} | null> : SchemaBuilder<{}>;
    /**
     * Create a string schema
     */
    static stringSchema<N extends boolean = false>(schema?: Pick<JSONSchema, JSONSchemaStringProperties>, nullable?: N): N extends true ? SchemaBuilder<string | null> : SchemaBuilder<string>;
    /**
     * Create a number schema
     */
    static numberSchema<N extends boolean = false>(schema?: Pick<JSONSchema, JSONSchemaNumberProperties>, nullable?: N): N extends true ? SchemaBuilder<number | null> : SchemaBuilder<number>;
    /**
     * Create an integer schema
     */
    static integerSchema<N extends boolean = false>(schema?: Pick<JSONSchema, JSONSchemaNumberProperties>, nullable?: boolean): N extends true ? SchemaBuilder<number | null> : SchemaBuilder<number>;
    /**
     * Create a boolean schema
     */
    static booleanSchema<N extends boolean = false>(schema?: Pick<JSONSchema, JSONSchemaProperties>, nullable?: boolean): N extends true ? SchemaBuilder<boolean | null> : SchemaBuilder<boolean>;
    /**
     * Create an enum schema
     */
    static enumSchema<K extends string | number | boolean, N extends boolean = false>(values: readonly K[], schema?: Pick<JSONSchema, JSONSchemaProperties>, nullable?: boolean): N extends true ? SchemaBuilder<K | null> : SchemaBuilder<K>;
    /**
     * Create an array schema
     */
    static arraySchema<U, N extends boolean = false>(items: SchemaBuilder<U>, schema?: Pick<JSONSchema, JSONSchemaArrayProperties>, nullable?: boolean): N extends true ? SchemaBuilder<U[] | null> : SchemaBuilder<U[]>;
    /**
     * Return a schema builder which validate any one of the provided schemas exclusively. "oneOf" as described by JSON Schema specifications.
     */
    static oneOf<S extends SchemaBuilder<any>[]>(...schemaBuilders: S): SchemaBuilder<OneOf<S>>;
    /**
     * Return a schema builder which validate all the provided schemas. "allOf" as described by JSON Schema specifications.
     */
    static allOf<S extends SchemaBuilder<any>[]>(...schemaBuilders: S): SchemaBuilder<AllOf<S>>;
    /**
     * Return a schema builder which validate any number the provided schemas. "anyOf" as described by JSON Schema specifications.
     */
    static anyOf<S extends SchemaBuilder<any>[]>(...schemaBuilders: S): SchemaBuilder<OneOf<S>>;
    /**
     * Return a schema builder which represents the negation of the given schema. The only type we can assume is "any". "not" as described by JSON Schema specifications.
     */
    static not(schemaBuilder: SchemaBuilder<any>): SchemaBuilder<any>;
    /**
     * Make given properties optionals
     */
    setOptionalProperties<K extends keyof T>(properties: readonly K[]): SchemaBuilder<PartialProperties<T, K>>;
    /**
     * Make given properties required
     */
    setRequiredProperties<K extends keyof T>(properties: readonly K[]): SchemaBuilder<RequiredProperties<T, K>>;
    /**
     * Make all properties optionals and remove their default values
     */
    toOptionals(): SchemaBuilder<{
        [P in keyof T]?: T[P];
    }>;
    /**
     * Make all properties and subproperties optionals
     * Remove all default values
     */
    toDeepOptionals(): SchemaBuilder<DeepPartial<T>>;
    /**
     * Make all optional properties of this schema nullable
     */
    toNullable(): SchemaBuilder<Nullable<T>>;
    /**
     * Add a property using the given schema builder
     */
    addProperty<U, K extends keyof any, REQUIRED extends boolean = true>(propertyName: K, schemaBuilder: SchemaBuilder<U>, isRequired?: REQUIRED): SchemaBuilder<Combine<T, U, K, REQUIRED, false>>;
    /**
     * Replace an existing property of this schema
     */
    replaceProperty<U, K extends keyof T, REQUIRED extends boolean = true>(propertyName: K, schemaBuilder: SchemaBuilder<U>, isRequired?: REQUIRED): SchemaBuilder<Combine<Omit<T, K>, U, K, REQUIRED, false>>;
    addOrReplaceProperty<U, K extends keyof any, REQUIRED extends boolean = true>(propertyName: K, schemaBuilder: SchemaBuilder<U>, isRequired?: REQUIRED): SchemaBuilder<Combine<Omit<T, K>, U, K, REQUIRED, false>>;
    /**
     * Add additional properties schema.
     * /!\ Many type operations can't work properly with index signatures. Try to use additionalProperties at the last step of your SchemaBuilder definition.
     * /!\ In typescript index signature MUST be compatible with other properties. However its supported in JSON schema, you can use it but you have to force the index singature to any.
     */
    addAdditionalProperties<U = any>(schemaBuilder?: SchemaBuilder<U>): SchemaBuilder<T & {
        [P: string]: U;
    }>;
    /**
     * Add a string to the schema properties
     */
    addString<K extends keyof any, REQUIRED extends boolean = true, N extends boolean = false>(propertyName: K, schema?: Pick<JSONSchema, JSONSchemaStringProperties>, isRequired?: REQUIRED, nullable?: N): SchemaBuilder<Combine<T, string, K, REQUIRED, N>>;
    /**
     * Add a string enum to the schema properties
     */
    addEnum<K extends keyof any, K2 extends string | boolean | number, REQUIRED extends boolean = true, N extends boolean = false>(propertyName: K, values: readonly K2[], schema?: Pick<JSONSchema, JSONSchemaStringProperties>, isRequired?: REQUIRED, nullable?: N): SchemaBuilder<Combine<T, K2, K, REQUIRED, N>>;
    /**
     * Add a number to the schema properties
     */
    addNumber<K extends keyof any, REQUIRED extends boolean = true, N extends boolean = false>(propertyName: K, schema?: Pick<JSONSchema, JSONSchemaNumberProperties>, isRequired?: REQUIRED, nullable?: N): SchemaBuilder<Combine<T, number, K, REQUIRED, N>>;
    /**
     * Add an integer to the schema properties
     */
    addInteger<K extends keyof any, REQUIRED extends boolean = true, N extends boolean = false>(propertyName: K, schema?: Pick<JSONSchema, JSONSchemaNumberProperties>, isRequired?: REQUIRED, nullable?: N): SchemaBuilder<Combine<T, number, K, REQUIRED, N>>;
    /**
     * Add a number to the schema properties
     */
    addBoolean<K extends keyof any, REQUIRED extends boolean = true, N extends boolean = false>(propertyName: K, schema?: Pick<JSONSchema, JSONSchemaProperties>, isRequired?: REQUIRED, nullable?: N): SchemaBuilder<Combine<T, boolean, K, REQUIRED, N>>;
    /**
     * Add an array of objects to the schema properties
     */
    addArray<U extends {}, K extends keyof any, REQUIRED extends boolean = true, N extends boolean = false>(propertyName: K, items: SchemaBuilder<U>, schema?: Pick<JSONSchema, JSONSchemaArrayProperties>, isRequired?: REQUIRED, nullable?: N): SchemaBuilder<Combine<T, U[], K, REQUIRED, N>>;
    /**
     * Rename the given property. The property schema remains unchanged.
     */
    renameProperty<K extends keyof T, K2 extends keyof any>(propertyName: K, newPropertyName: K2): SchemaBuilder<Rename<T, K, K2>>;
    /**
     * Filter the schema to contains only the given properties. additionalProperties is set to false.
     *
     * @param properties name of properties of T to keep in the result
     */
    pickProperties<K extends keyof T>(properties: readonly K[]): SchemaBuilder<{
        [P in K]: T[P];
    }>;
    /**
     * Filter the schema to contains only the given properties and keep additionalProperties or part of it
     *
     * @param properties
     * @param additionalProperties [] means no additonal properties are kept in the result. undefined means additionalProperties is kept or set to true if it was not set to false. ['aProperty'] allows you to capture only specific names that conform to additionalProperties type.
     */
    pickAdditionalProperties<K extends keyof T, K2 extends keyof T = any>(properties: readonly K[], additionalProperties?: readonly K2[]): SchemaBuilder<Pick<T, K> & {
        [P in K2]: T[P];
    }>;
    /**
     * Filter the schema to contains everything except the given properties.
     */
    omitProperties<K extends keyof T>(properties: readonly K[]): SchemaBuilder<Omit<T, K>>;
    /**
     * Transform properties to accept an alternative type. additionalProperties is set false.
     *
     * @param changedProperties properties that will have the alternative type
     * @param schemaBuilder
     */
    transformProperties<U, K extends keyof T>(schemaBuilder: SchemaBuilder<U>, propertyNames?: readonly K[]): SchemaBuilder<TransformProperties<T, K, U>>;
    /**
     * Transform the given properties to make them alternatively an array of the initial type.
     * If the property is already an Array nothing happen.
     *
     * @param propertyNames properties that will have the alternative array type
     */
    transformPropertiesToArray<K extends keyof T>(propertyNames?: readonly K[]): SchemaBuilder<TransformPropertiesToArray<T, K>>;
    /**
     * Unwrap the given array properties to make them alternatively the generic type of the array
     * If the property is not an Array nothing happen.
     *
     * @param propertyNames properties that will be unwrapped
     */
    unwrapArrayProperties<K extends keyof T>(propertyNames?: readonly K[]): SchemaBuilder<UnwrapArrayProperties<T, K>>;
    /**
     * Merge all properties from the given schema into this one. If a property name is already used, a allOf statement is used.
     * This method only copy properties.
     */
    intersectProperties<T2>(schema: SchemaBuilder<T2>): SchemaBuilder<T & T2>;
    /**
     * Merge all properties from the given schema into this one. If a property name is already used, a anyOf statement is used.
     * This method only copy properties.
     */
    mergeProperties<T2>(schema: SchemaBuilder<T2>): SchemaBuilder<Merge<T, T2>>;
    /**
     * Overwrite all properties from the given schema into this one. If a property name is already used, the new type override the existing one.
     * This method only copy properties.
     */
    overwriteProperties<T2>(schema: SchemaBuilder<T2>): SchemaBuilder<Overwrite<T, T2>>;
    /**
     * Extract a subschema of the current object schema
     */
    getSubschema<K extends keyof T>(propertyName: K): SchemaBuilder<T[K]>;
    /**
     * Extract the item schema of the current array schema
     */
    getItemsSubschema(): SchemaBuilder<T extends (infer ITEMS)[] ? ITEMS : never>;
    /**
     * true if additionalProperties is set to false and, oneOf, allOf, anyOf and not are not used
     */
    get isSimpleObjectSchema(): boolean;
    /**
     * true if the schema represent an object
     */
    get isObjectSchema(): boolean;
    /**
     * True if the schema represents an objet that can have additional properties
     */
    get hasAdditionalProperties(): boolean;
    /**
     * True if the schema contains oneOf, allOf, anyOf or not keywords
     */
    get hasSchemasCombinationKeywords(): boolean;
    get properties(): T extends object ? KnownKeys<T>[] : null;
    get requiredProperties(): T extends object ? RequiredKnownKeys<T>[] : null;
    get optionalProperties(): T extends object ? OptionalKnownKeys<T>[] : null;
    /**
     * change general schema attributes
     *
     * @property schema
     */
    setSchemaAttributes(schema: Pick<JSONSchema, JSONSchemaGeneralProperties>): SchemaBuilder<{
        [P in keyof T]: T[P];
    }>;
    /**
     * Validate the given object against the schema. If the object is invalid an error is thrown with the appropriate details.
     */
    validate(o: T): void;
    protected ajv: any;
    protected validationFunction: any;
    /**
     * Validate the given list of object against the schema. If any object is invalid, an error is thrown with the appropriate details.
     */
    validateList(list: T[]): void;
    protected ajvList: any;
    protected listValidationFunction: any;
    /**
     * Change the default Ajv configuration to use the given values. Any cached validation function is cleared.
     * The default validation config is { coerceTypes: false, removeAdditional: false, useDefaults: true }
     */
    configureValidation(validationConfig: Ajv.Options): this;
    protected defaultValidationConfig: Ajv.Options;
    protected clearCache(): void;
    get ajvValidationConfig(): {
        $data?: boolean | undefined;
        allErrors?: boolean | undefined;
        verbose?: boolean | undefined;
        jsonPointers?: boolean | undefined;
        uniqueItems?: boolean | undefined;
        unicode?: boolean | undefined;
        format?: string | false | undefined;
        formats?: object | undefined;
        keywords?: object | undefined;
        unknownFormats?: true | string[] | "ignore" | undefined;
        schemas?: object | object[] | undefined;
        schemaId?: "id" | "$id" | "auto" | undefined;
        missingRefs?: true | "ignore" | "fail" | undefined;
        extendRefs?: true | "ignore" | "fail" | undefined;
        loadSchema?: ((uri: string, cb?: ((err: Error, schema: object) => void) | undefined) => PromiseLike<boolean | object>) | undefined;
        removeAdditional?: boolean | "all" | "failing" | undefined;
        useDefaults?: boolean | "empty" | "shared" | undefined;
        coerceTypes?: boolean | "array" | undefined;
        strictDefaults?: boolean | "log" | undefined;
        strictKeywords?: boolean | "log" | undefined;
        strictNumbers?: boolean | undefined;
        async?: string | boolean | undefined;
        transpile?: string | ((code: string) => string) | undefined;
        meta?: boolean | object | undefined;
        validateSchema?: boolean | "log" | undefined;
        addUsedSchema?: boolean | undefined;
        inlineRefs?: number | boolean | undefined;
        passContext?: boolean | undefined;
        loopRequired?: number | undefined;
        ownProperties?: boolean | undefined;
        multipleOfPrecision?: number | boolean | undefined;
        errorDataPath?: string | undefined;
        messages?: boolean | undefined;
        sourceCode?: boolean | undefined;
        processCode?: ((code: string, schema: object) => string) | undefined;
        cache?: object | undefined;
        logger?: false | Ajv.CustomLogger | undefined;
        nullable?: boolean | undefined;
        serialize?: false | ((schema: boolean | object) => any) | undefined;
    } | {
        $data?: boolean | undefined;
        allErrors?: boolean | undefined;
        verbose?: boolean | undefined;
        jsonPointers?: boolean | undefined;
        uniqueItems?: boolean | undefined;
        unicode?: boolean | undefined;
        format?: string | false | undefined;
        formats?: object | undefined;
        keywords?: object | undefined;
        unknownFormats?: true | string[] | "ignore" | undefined;
        schemas?: object | object[] | undefined;
        schemaId?: "id" | "$id" | "auto" | undefined;
        missingRefs?: true | "ignore" | "fail" | undefined;
        extendRefs?: true | "ignore" | "fail" | undefined;
        loadSchema?: ((uri: string, cb?: ((err: Error, schema: object) => void) | undefined) => PromiseLike<boolean | object>) | undefined;
        removeAdditional?: boolean | "all" | "failing" | undefined;
        useDefaults?: boolean | "empty" | "shared" | undefined;
        coerceTypes?: boolean | "array" | undefined;
        strictDefaults?: boolean | "log" | undefined;
        strictKeywords?: boolean | "log" | undefined;
        strictNumbers?: boolean | undefined;
        async?: string | boolean | undefined;
        transpile?: string | ((code: string) => string) | undefined;
        meta?: boolean | object | undefined;
        validateSchema?: boolean | "log" | undefined;
        addUsedSchema?: boolean | undefined;
        inlineRefs?: number | boolean | undefined;
        passContext?: boolean | undefined;
        loopRequired?: number | undefined;
        ownProperties?: boolean | undefined;
        multipleOfPrecision?: number | boolean | undefined;
        errorDataPath?: string | undefined;
        messages?: boolean | undefined;
        sourceCode?: boolean | undefined;
        processCode?: ((code: string, schema: object) => string) | undefined;
        cache?: object | undefined;
        logger?: false | Ajv.CustomLogger | undefined;
        nullable?: boolean | undefined;
        serialize?: false | ((schema: boolean | object) => any) | undefined;
    };
    /**
     * Explicitly cache the validation function for single objects with the current validation configuration
     */
    cacheValidationFunction(): void;
    /**
     * Explicitly cache the validation function for list of objects with the current validation configuration
     */
    cacheListValidationFunction(): void;
    /**
     * This property makes the access to the underlying T type easy.
     * You can do things like type MyModel = typeof myModelSchemaBuilder.T
     * Or use GenericType["T"] in a generic type definition.
     * It's not supposed to be set or accessed
     */
    readonly T: {
        [P in keyof T]: T[P];
    };
}
export declare type JSONSchemaArrayProperties = "description" | "default" | "maxItems" | "minItems" | "uniqueItems" | "examples" | "readOnly" | "writeOnly";
export declare type JSONSchemaStringProperties = "description" | "default" | "maxLength" | "minLength" | "pattern" | "format" | "examples" | "readOnly" | "writeOnly";
export declare type JSONSchemaNumberProperties = "description" | "default" | "multipleOf" | "maximum" | "exclusiveMaximum" | "minimum" | "exclusiveMinimum" | "examples" | "readOnly" | "writeOnly";
export declare type JSONSchemaProperties = "description" | "default" | "examples" | "readOnly" | "writeOnly";
export declare type JSONSchemaObjectProperties = "title" | "description" | "maxProperties" | "minProperties" | "default" | "examples" | "readOnly" | "writeOnly";
export declare type JSONSchemaGeneralProperties = "title" | "description" | "default" | "examples";

(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "SchemaBuilder", function() { return /* reexport */ SchemaBuilder_SchemaBuilder; });

// EXTERNAL MODULE: external "ajv"
var external_ajv_ = __webpack_require__(3);

// EXTERNAL MODULE: external "verror"
var external_verror_ = __webpack_require__(2);

// CONCATENATED MODULE: ./src/SchemaBuilder.ts
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};


/**
 * Represents a JSON Schema and its type.
 */
var SchemaBuilder_SchemaBuilder = /** @class */ (function () {
    /**
     * Initialize a new SchemaBuilder instance.
     * /!\ schemaObject must not contain references. If you have references, use something like json-schema-ref-parser library first.
     */
    function SchemaBuilder(schemaObject, validationConfig) {
        this.schemaObject = schemaObject;
        this.validationConfig = validationConfig;
        this.defaultValidationConfig = {
            coerceTypes: false,
            removeAdditional: false,
            useDefaults: true,
        };
        /**
         * This property makes the access to the underlying T type easy.
         * You can do things like type MyModel = typeof myModelSchemaBuilder.T
         * Or use GenericType["T"] in a generic type definition.
         * It's not supposed to be set or accessed
         */
        this.T = null;
        throughJsonSchema(this.schemaObject, function (s) {
            if ("$ref" in s) {
                throw new external_verror_("Schema Builder Error: $ref can't be used to initialize a SchemaBuilder. Dereferenced the schema first.");
            }
        });
    }
    Object.defineProperty(SchemaBuilder.prototype, "schema", {
        /**
         * Get the JSON schema object
         */
        get: function () {
            return this.schemaObject;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Function that take an inline JSON schema and deduces its type automatically!
     * Type, enums and required have to be string literals for this function to work... So you'll probably have to use contants (ex: STRING_TYPE), use the helper 'keys' function or pass the schema itself as the generic type argument.
     */
    SchemaBuilder.fromJsonSchema = function (schema, validationConfig) {
        return new SchemaBuilder(schema, validationConfig);
    };
    /**
     * Create an empty object schema
     * AdditionalProperties is automatically set to false
     */
    SchemaBuilder.emptySchema = function (schema, nullable) {
        if (schema === void 0) { schema = {}; }
        var s = __assign(__assign({}, cloneJSON(schema)), { type: nullable ? ["object", "null"] : "object", additionalProperties: false });
        return new SchemaBuilder(s);
    };
    /**
     * Create a string schema
     */
    SchemaBuilder.stringSchema = function (schema, nullable) {
        if (schema === void 0) { schema = {}; }
        var s = __assign(__assign({}, cloneJSON(schema)), { type: nullable ? ["string", "null"] : "string" });
        return new SchemaBuilder(s);
    };
    /**
     * Create a number schema
     */
    SchemaBuilder.numberSchema = function (schema, nullable) {
        if (schema === void 0) { schema = {}; }
        var s = __assign(__assign({}, cloneJSON(schema)), { type: nullable ? ["number", "null"] : "number" });
        return new SchemaBuilder(s);
    };
    /**
     * Create an integer schema
     */
    SchemaBuilder.integerSchema = function (schema, nullable) {
        if (schema === void 0) { schema = {}; }
        var s = __assign(__assign({}, cloneJSON(schema)), { type: nullable ? ["integer", "null"] : "integer" });
        return new SchemaBuilder(s);
    };
    /**
     * Create a boolean schema
     */
    SchemaBuilder.booleanSchema = function (schema, nullable) {
        if (schema === void 0) { schema = {}; }
        var s = __assign(__assign({}, cloneJSON(schema)), { type: nullable ? ["boolean", "null"] : "boolean" });
        return new SchemaBuilder(s);
    };
    /**
     * Create an enum schema
     */
    SchemaBuilder.enumSchema = function (values, schema, nullable) {
        if (schema === void 0) { schema = {}; }
        var types = [];
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            if (typeof value === "string" && !types.find(function (type) { return type === "string"; })) {
                types.push("string");
            }
            if (typeof value === "boolean" && !types.find(function (type) { return type === "boolean"; })) {
                types.push("boolean");
            }
            if (typeof value === "number" && !types.find(function (type) { return type === "number"; })) {
                types.push("number");
            }
        }
        if (nullable) {
            types.push("null");
        }
        var s = __assign(__assign({}, cloneJSON(schema)), { type: types.length === 1 ? types[0] : types, enum: nullable ? __spreadArrays(values, [null]) : values });
        return new SchemaBuilder(s);
    };
    /**
     * Create an array schema
     */
    SchemaBuilder.arraySchema = function (items, schema, nullable) {
        if (schema === void 0) { schema = {}; }
        var s = __assign(__assign({}, cloneJSON(schema)), { type: nullable ? ["array", "null"] : "array", items: cloneJSON(items.schemaObject) });
        return new SchemaBuilder(s);
    };
    /**
     * Return a schema builder which validate any one of the provided schemas exclusively. "oneOf" as described by JSON Schema specifications.
     */
    SchemaBuilder.oneOf = function () {
        var schemaBuilders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            schemaBuilders[_i] = arguments[_i];
        }
        return new SchemaBuilder({
            oneOf: schemaBuilders.map(function (builder) { return cloneJSON(builder.schemaObject); }),
        });
    };
    /**
     * Return a schema builder which validate all the provided schemas. "allOf" as described by JSON Schema specifications.
     */
    SchemaBuilder.allOf = function () {
        var schemaBuilders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            schemaBuilders[_i] = arguments[_i];
        }
        return new SchemaBuilder({
            allOf: schemaBuilders.map(function (builder) { return cloneJSON(builder.schemaObject); }),
        });
    };
    /**
     * Return a schema builder which validate any number the provided schemas. "anyOf" as described by JSON Schema specifications.
     */
    SchemaBuilder.anyOf = function () {
        var schemaBuilders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            schemaBuilders[_i] = arguments[_i];
        }
        return new SchemaBuilder({
            anyOf: schemaBuilders.map(function (builder) { return cloneJSON(builder.schemaObject); }),
        });
    };
    /**
     * Return a schema builder which represents the negation of the given schema. The only type we can assume is "any". "not" as described by JSON Schema specifications.
     */
    SchemaBuilder.not = function (schemaBuilder) {
        return new SchemaBuilder({
            not: cloneJSON(schemaBuilder.schemaObject),
        });
    };
    /**
     * Make given properties optionals
     */
    SchemaBuilder.prototype.setOptionalProperties = function (properties) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'setOptionalProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        // determine the new set of required properties
        var required = [];
        var existingRequired = schemaObject.required || [];
        var optionalProperties = []; // properties that are changing from required to optional
        for (var _i = 0, existingRequired_1 = existingRequired; _i < existingRequired_1.length; _i++) {
            var existingRequiredProperty = existingRequired_1[_i];
            if (properties.indexOf(existingRequiredProperty) === -1) {
                required.push(existingRequiredProperty);
            }
            else {
                optionalProperties.push(existingRequiredProperty);
            }
        }
        // clear default values for optional properties
        for (var _a = 0, optionalProperties_1 = optionalProperties; _a < optionalProperties_1.length; _a++) {
            var optionalProperty = optionalProperties_1[_a];
            var property = schemaObject.properties[optionalProperty];
            if (property && typeof property !== "boolean") {
                delete property.default;
            }
        }
        // delete required array if empty
        if (required.length === 0) {
            delete schemaObject.required;
        }
        else {
            schemaObject.required = required;
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Make given properties required
     */
    SchemaBuilder.prototype.setRequiredProperties = function (properties) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'setRequiredProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            schemaObject.required = schemaObject.required || [];
            if (schemaObject.required.indexOf(property) === -1) {
                schemaObject.required.push(property);
            }
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Make all properties optionals and remove their default values
     */
    SchemaBuilder.prototype.toOptionals = function () {
        var schemaObject = cloneJSON(this.schemaObject);
        delete schemaObject.required;
        // remove default values for optional properties
        for (var property in schemaObject.properties) {
            delete schemaObject.properties[property].default;
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Make all properties and subproperties optionals
     * Remove all default values
     */
    SchemaBuilder.prototype.toDeepOptionals = function () {
        var schemaObject = cloneJSON(this.schemaObject);
        throughJsonSchema(schemaObject, function (s) {
            delete s.required;
            // optional properties can't have default values
            delete s.default;
        });
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Make all optional properties of this schema nullable
     */
    SchemaBuilder.prototype.toNullable = function () {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'toNullable' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        var required = schemaObject.required || [];
        for (var propertyName in schemaObject.properties) {
            if (required.indexOf(propertyName) === -1) {
                var propertyValue = schemaObject.properties[propertyName];
                if (typeof propertyValue !== "boolean" && "type" in propertyValue) {
                    if (Array.isArray(propertyValue.type) && propertyValue.type.indexOf("null") === -1) {
                        propertyValue.type = __spreadArrays(propertyValue.type, ["null"]);
                    }
                    else if (typeof propertyValue.type === "string" && propertyValue.type !== "null") {
                        propertyValue.type = [propertyValue.type, "null"];
                    }
                    if ("enum" in propertyValue && propertyValue.enum.indexOf(null) === -1) {
                        propertyValue.enum = __spreadArrays(propertyValue.enum, [null]);
                    }
                }
                else {
                    schemaObject.properties[propertyName] = {
                        anyOf: [schemaObject.properties[propertyName], { type: "null" }],
                    };
                }
            }
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Add a property using the given schema builder
     */
    SchemaBuilder.prototype.addProperty = function (propertyName, schemaBuilder, isRequired) {
        if (!this.isObjectSchema) {
            throw new external_verror_("Schema Builder Error: you can only add properties to an object schema");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.properties = schemaObject.properties || {};
        if (propertyName in schemaObject.properties) {
            throw new external_verror_("Schema Builder Error: '" + propertyName + "' already exists in " + (schemaObject.title || "this") + " schema");
        }
        schemaObject.properties[propertyName] = cloneJSON(schemaBuilder.schemaObject);
        if (isRequired === true || isRequired === undefined) {
            schemaObject.required = schemaObject.required || [];
            schemaObject.required.push(propertyName);
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Replace an existing property of this schema
     */
    SchemaBuilder.prototype.replaceProperty = function (propertyName, schemaBuilder, isRequired) {
        if (!this.isObjectSchema) {
            throw new external_verror_("Schema Builder Error: you can only replace properties of an object schema");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.properties = schemaObject.properties || {};
        if (schemaObject.required) {
            schemaObject.required = schemaObject.required.filter(function (p) { return p !== propertyName; });
        }
        schemaObject.properties[propertyName] = cloneJSON(schemaBuilder.schemaObject);
        if (isRequired === true || isRequired === undefined) {
            schemaObject.required = schemaObject.required || [];
            schemaObject.required.push(propertyName);
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    SchemaBuilder.prototype.addOrReplaceProperty = function (propertyName, schemaBuilder, isRequired) {
        return this.replaceProperty(propertyName, schemaBuilder, isRequired);
    };
    /**
     * Add additional properties schema.
     * /!\ Many type operations can't work properly with index signatures. Try to use additionalProperties at the last step of your SchemaBuilder definition.
     * /!\ In typescript index signature MUST be compatible with other properties. However its supported in JSON schema, you can use it but you have to force the index singature to any.
     */
    SchemaBuilder.prototype.addAdditionalProperties = function (schemaBuilder) {
        if (this.schemaObject.additionalProperties) {
            throw new external_verror_("Schema Builder Error: additionalProperties is already set in " + (this.schemaObject.title || "this") + " schema.");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.additionalProperties = schemaBuilder ? cloneJSON(schemaBuilder.schemaObject) : true;
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Add a string to the schema properties
     */
    SchemaBuilder.prototype.addString = function (propertyName, schema, isRequired, nullable) {
        if (schema === void 0) { schema = {}; }
        return this.addProperty(propertyName, SchemaBuilder.stringSchema(schema, nullable), isRequired);
    };
    /**
     * Add a string enum to the schema properties
     */
    SchemaBuilder.prototype.addEnum = function (propertyName, values, schema, isRequired, nullable) {
        if (schema === void 0) { schema = {}; }
        return this.addProperty(propertyName, SchemaBuilder.enumSchema(values, schema, nullable), isRequired);
    };
    /**
     * Add a number to the schema properties
     */
    SchemaBuilder.prototype.addNumber = function (propertyName, schema, isRequired, nullable) {
        if (schema === void 0) { schema = {}; }
        return this.addProperty(propertyName, SchemaBuilder.numberSchema(schema, nullable), isRequired);
    };
    /**
     * Add an integer to the schema properties
     */
    SchemaBuilder.prototype.addInteger = function (propertyName, schema, isRequired, nullable) {
        if (schema === void 0) { schema = {}; }
        return this.addProperty(propertyName, SchemaBuilder.integerSchema(schema, nullable), isRequired);
    };
    /**
     * Add a number to the schema properties
     */
    SchemaBuilder.prototype.addBoolean = function (propertyName, schema, isRequired, nullable) {
        if (schema === void 0) { schema = {}; }
        return this.addProperty(propertyName, SchemaBuilder.booleanSchema(schema, nullable), isRequired);
    };
    /**
     * Add an array of objects to the schema properties
     */
    SchemaBuilder.prototype.addArray = function (propertyName, items, schema, isRequired, nullable) {
        if (schema === void 0) { schema = {}; }
        return this.addProperty(propertyName, SchemaBuilder.arraySchema(items, schema, nullable), isRequired);
    };
    /**
     * Rename the given property. The property schema remains unchanged.
     */
    SchemaBuilder.prototype.renameProperty = function (propertyName, newPropertyName) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'renameProperty' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.properties = schemaObject.properties || {};
        if (propertyName in schemaObject.properties) {
            schemaObject.properties[newPropertyName] = schemaObject.properties[propertyName];
            delete schemaObject.properties[propertyName];
            // rename the property in the required array if needed
            if (schemaObject.required && schemaObject.required.indexOf(propertyName) !== -1) {
                schemaObject.required.splice(schemaObject.required.indexOf(propertyName), 1);
                schemaObject.required.push(newPropertyName);
            }
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Filter the schema to contains only the given properties. additionalProperties is set to false.
     *
     * @param properties name of properties of T to keep in the result
     */
    SchemaBuilder.prototype.pickProperties = function (properties) {
        if (!this.isObjectSchema || this.hasSchemasCombinationKeywords) {
            throw new external_verror_("Schema Builder Error: 'pickProperties' can only be used with a simple object schema (no oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.properties = schemaObject.properties || {};
        var propertiesMap = {};
        for (var _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {
            var property = properties_2[_i];
            propertiesMap[property] = schemaObject.properties[property];
        }
        schemaObject.properties = propertiesMap;
        if (schemaObject.required) {
            schemaObject.required = schemaObject.required.filter(function (r) { return properties.indexOf(r) !== -1; });
        }
        if (Array.isArray(schemaObject.required) && schemaObject.required.length === 0) {
            delete schemaObject.required;
        }
        schemaObject.additionalProperties = false;
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Filter the schema to contains only the given properties and keep additionalProperties or part of it
     *
     * @param properties
     * @param additionalProperties [] means no additonal properties are kept in the result. undefined means additionalProperties is kept or set to true if it was not set to false. ['aProperty'] allows you to capture only specific names that conform to additionalProperties type.
     */
    SchemaBuilder.prototype.pickAdditionalProperties = function (properties, additionalProperties) {
        if (!this.isObjectSchema || !this.hasAdditionalProperties || this.hasSchemasCombinationKeywords) {
            throw new external_verror_("Schema Builder Error: 'pickPropertiesIncludingAdditonalProperties' can only be used with a simple object schema with additionalProperties (no oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        var additionalProps = schemaObject.additionalProperties;
        schemaObject.properties = schemaObject.properties || {};
        var propertiesMap = {};
        for (var _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {
            var property = properties_3[_i];
            propertiesMap[property] = schemaObject.properties[property];
        }
        schemaObject.properties = propertiesMap;
        if (schemaObject.required) {
            schemaObject.required = schemaObject.required.filter(function (r) { return properties.indexOf(r) !== -1; });
        }
        if (Array.isArray(schemaObject.required) && schemaObject.required.length === 0) {
            delete schemaObject.required;
        }
        if (!additionalProperties) {
            schemaObject.additionalProperties = additionalProps ? additionalProps : true;
        }
        else if (Array.isArray(additionalProperties) && additionalProperties.length === 0) {
            schemaObject.additionalProperties = false;
        }
        else {
            schemaObject.additionalProperties = false;
            schemaObject.required = schemaObject.required || [];
            for (var _a = 0, additionalProperties_1 = additionalProperties; _a < additionalProperties_1.length; _a++) {
                var additionalProperty = additionalProperties_1[_a];
                schemaObject.properties[additionalProperty] = typeof additionalProps === "boolean" ? {} : cloneJSON(additionalProps);
                schemaObject.required.push(additionalProperty);
            }
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Filter the schema to contains everything except the given properties.
     */
    SchemaBuilder.prototype.omitProperties = function (properties) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'omitProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var p = Object.keys(this.schemaObject.properties || {}).filter(function (k) { return properties.indexOf(k) === -1; });
        return this.pickProperties(p);
    };
    /**
     * Transform properties to accept an alternative type. additionalProperties is set false.
     *
     * @param changedProperties properties that will have the alternative type
     * @param schemaBuilder
     */
    SchemaBuilder.prototype.transformProperties = function (schemaBuilder, propertyNames) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'transformProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.properties = schemaObject.properties || {};
        propertyNames = propertyNames || Object.keys(schemaObject.properties);
        for (var _i = 0, propertyNames_1 = propertyNames; _i < propertyNames_1.length; _i++) {
            var property = propertyNames_1[_i];
            var propertySchema = schemaObject.properties[property];
            schemaObject.properties[property] = {
                oneOf: [propertySchema, cloneJSON(schemaBuilder.schemaObject)],
            };
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Transform the given properties to make them alternatively an array of the initial type.
     * If the property is already an Array nothing happen.
     *
     * @param propertyNames properties that will have the alternative array type
     */
    SchemaBuilder.prototype.transformPropertiesToArray = function (propertyNames) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'transformPropertiesToArray' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.properties = schemaObject.properties || {};
        propertyNames = propertyNames || Object.keys(schemaObject.properties);
        for (var _i = 0, propertyNames_2 = propertyNames; _i < propertyNames_2.length; _i++) {
            var property = propertyNames_2[_i];
            var propertySchema = schemaObject.properties[property];
            // Transform the property if it's not an array
            if (propertySchema.type !== "array") {
                schemaObject.properties[property] = {
                    oneOf: [propertySchema, { type: "array", items: cloneJSON(propertySchema) }],
                };
            }
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Unwrap the given array properties to make them alternatively the generic type of the array
     * If the property is not an Array nothing happen.
     *
     * @param propertyNames properties that will be unwrapped
     */
    SchemaBuilder.prototype.unwrapArrayProperties = function (propertyNames) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'unwrapArrayProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject = cloneJSON(this.schemaObject);
        schemaObject.properties = schemaObject.properties || {};
        propertyNames = propertyNames || Object.keys(schemaObject.properties);
        for (var _i = 0, propertyNames_3 = propertyNames; _i < propertyNames_3.length; _i++) {
            var property = propertyNames_3[_i];
            var propertySchema = schemaObject.properties[property];
            // Transform the property if it's an array
            if (propertySchema.type === "array") {
                var items = propertySchema.items;
                var itemsSchema = void 0;
                if (Array.isArray(items)) {
                    if (items.length === 1) {
                        itemsSchema = items[0];
                    }
                    else {
                        itemsSchema = { oneOf: items };
                    }
                }
                else {
                    itemsSchema = items;
                }
                schemaObject.properties[property] = {
                    oneOf: [cloneJSON(itemsSchema), propertySchema],
                };
            }
        }
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Merge all properties from the given schema into this one. If a property name is already used, a allOf statement is used.
     * This method only copy properties.
     */
    SchemaBuilder.prototype.intersectProperties = function (schema) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'intersectProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject1 = cloneJSON(this.schemaObject);
        var schemaObject2 = cloneJSON(schema.schemaObject);
        if (schemaObject2.properties) {
            schemaObject1.properties = schemaObject1.properties || {};
            for (var propertyKey in schemaObject2.properties) {
                if (!(propertyKey in schemaObject1.properties)) {
                    schemaObject1.properties[propertyKey] = schemaObject2.properties[propertyKey];
                    if (schemaObject2.required && schemaObject2.required.indexOf(propertyKey) !== -1) {
                        schemaObject1.required = schemaObject1.required || [];
                        schemaObject1.required.push(propertyKey);
                    }
                }
                else {
                    schemaObject1.properties[propertyKey] = {
                        allOf: [schemaObject1.properties[propertyKey], schemaObject2.properties[propertyKey]],
                    };
                    if (schemaObject2.required &&
                        schemaObject2.required.indexOf(propertyKey) !== -1 &&
                        (!schemaObject1.required || schemaObject1.required.indexOf(propertyKey) === -1)) {
                        schemaObject1.required = schemaObject1.required || [];
                        schemaObject1.required.push(propertyKey);
                    }
                }
            }
        }
        return new SchemaBuilder(schemaObject1, this.validationConfig);
    };
    /**
     * Merge all properties from the given schema into this one. If a property name is already used, a anyOf statement is used.
     * This method only copy properties.
     */
    SchemaBuilder.prototype.mergeProperties = function (schema) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'mergeProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject1 = cloneJSON(this.schemaObject);
        var schemaObject2 = cloneJSON(schema.schemaObject);
        if (schemaObject2.properties) {
            schemaObject1.properties = schemaObject1.properties || {};
            var _loop_1 = function (propertyKey) {
                if (!(propertyKey in schemaObject1.properties)) {
                    schemaObject1.properties[propertyKey] = schemaObject2.properties[propertyKey];
                    if (schemaObject2.required && schemaObject2.required.indexOf(propertyKey) !== -1) {
                        schemaObject1.required = schemaObject1.required || [];
                        schemaObject1.required.push(propertyKey);
                    }
                }
                else {
                    schemaObject1.properties[propertyKey] = {
                        anyOf: [schemaObject1.properties[propertyKey], schemaObject2.properties[propertyKey]],
                    };
                    if (schemaObject1.required &&
                        schemaObject1.required.indexOf(propertyKey) !== -1 &&
                        (!schemaObject2.required || schemaObject2.required.indexOf(propertyKey) === -1)) {
                        schemaObject1.required = schemaObject1.required.filter(function (p) { return p !== propertyKey; });
                    }
                }
            };
            for (var propertyKey in schemaObject2.properties) {
                _loop_1(propertyKey);
            }
        }
        return new SchemaBuilder(schemaObject1, this.validationConfig);
    };
    /**
     * Overwrite all properties from the given schema into this one. If a property name is already used, the new type override the existing one.
     * This method only copy properties.
     */
    SchemaBuilder.prototype.overwriteProperties = function (schema) {
        if (!this.isSimpleObjectSchema) {
            throw new external_verror_("Schema Builder Error: 'overwriteProperties' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        var schemaObject1 = cloneJSON(this.schemaObject);
        var schemaObject2 = cloneJSON(schema.schemaObject);
        if (schemaObject2.properties) {
            schemaObject1.properties = schemaObject1.properties || {};
            var _loop_2 = function (propertyKey) {
                if (!(propertyKey in schemaObject1.properties)) {
                    schemaObject1.properties[propertyKey] = schemaObject2.properties[propertyKey];
                    if (schemaObject2.required && schemaObject2.required.indexOf(propertyKey) !== -1) {
                        schemaObject1.required = schemaObject1.required || [];
                        schemaObject1.required.push(propertyKey);
                    }
                }
                else {
                    schemaObject1.properties[propertyKey] = schemaObject2.properties[propertyKey];
                    if (schemaObject1.required && schemaObject1.required.indexOf(propertyKey) !== -1) {
                        schemaObject1.required = schemaObject1.required.filter(function (r) { return r !== propertyKey; });
                    }
                    if (schemaObject2.required && schemaObject2.required.indexOf(propertyKey) !== -1) {
                        schemaObject1.required = schemaObject1.required || [];
                        schemaObject1.required.push(propertyKey);
                    }
                }
            };
            for (var propertyKey in schemaObject2.properties) {
                _loop_2(propertyKey);
            }
        }
        return new SchemaBuilder(schemaObject1, this.validationConfig);
    };
    /**
     * Extract a subschema of the current object schema
     */
    SchemaBuilder.prototype.getSubschema = function (propertyName) {
        if (!this.isSimpleObjectSchema || !this.schemaObject || typeof this.schemaObject === "boolean" || !this.schemaObject.properties) {
            throw new external_verror_("Schema Builder Error: 'getSubschema' can only be used with a simple object schema (no additionalProperties, oneOf, anyOf, allOf or not)");
        }
        else {
            return new SchemaBuilder(this.schemaObject.properties[propertyName]);
        }
    };
    /**
     * Extract the item schema of the current array schema
     */
    SchemaBuilder.prototype.getItemsSubschema = function () {
        if (!this.schemaObject || this.schemaObject.type !== "array" || !this.schemaObject.items || Array.isArray(this.schemaObject.items)) {
            throw new external_verror_("Schema Builder Error: 'getItemsSubschema' can only be used with an array schema with non-array items");
        }
        else {
            return new SchemaBuilder(this.schemaObject.items);
        }
    };
    Object.defineProperty(SchemaBuilder.prototype, "isSimpleObjectSchema", {
        /**
         * true if additionalProperties is set to false and, oneOf, allOf, anyOf and not are not used
         */
        get: function () {
            return this.isObjectSchema && !this.hasAdditionalProperties && !this.hasSchemasCombinationKeywords;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SchemaBuilder.prototype, "isObjectSchema", {
        /**
         * true if the schema represent an object
         */
        get: function () {
            return this.schemaObject.type === "object" || (!("type" in this.schemaObject) && "properties" in this.schemaObject);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SchemaBuilder.prototype, "hasAdditionalProperties", {
        /**
         * True if the schema represents an objet that can have additional properties
         */
        get: function () {
            return this.isObjectSchema && this.schemaObject.additionalProperties !== false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SchemaBuilder.prototype, "hasSchemasCombinationKeywords", {
        /**
         * True if the schema contains oneOf, allOf, anyOf or not keywords
         */
        get: function () {
            return "oneOf" in this.schemaObject || "allOf" in this.schemaObject || "anyOf" in this.schemaObject || "not" in this.schemaObject;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SchemaBuilder.prototype, "properties", {
        get: function () {
            if (this.isObjectSchema && !this.hasSchemasCombinationKeywords) {
                return Object.keys(this.schemaObject.properties || {});
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SchemaBuilder.prototype, "requiredProperties", {
        get: function () {
            if (this.isObjectSchema && !this.hasSchemasCombinationKeywords) {
                return this.schemaObject.required ? __spreadArrays(this.schemaObject.required) : [];
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SchemaBuilder.prototype, "optionalProperties", {
        get: function () {
            var properties = this.properties;
            var required = this.requiredProperties;
            return properties ? properties.filter(function (property) { return required && required.indexOf(property) === -1; }) : null;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * change general schema attributes
     *
     * @property schema
     */
    SchemaBuilder.prototype.setSchemaAttributes = function (schema) {
        var schemaObject = __assign(__assign({}, cloneJSON(this.schemaObject)), schema);
        return new SchemaBuilder(schemaObject, this.validationConfig);
    };
    /**
     * Validate the given object against the schema. If the object is invalid an error is thrown with the appropriate details.
     */
    SchemaBuilder.prototype.validate = function (o) {
        // ensure validation function is cached
        this.cacheValidationFunction();
        // run validation
        var valid = this.validationFunction(o);
        // check if an error needs to be thrown
        if (!valid) {
            throw validationError(this.ajv.errorsText(this.validationFunction.errors), this.validationFunction.errors);
        }
    };
    /**
     * Validate the given list of object against the schema. If any object is invalid, an error is thrown with the appropriate details.
     */
    SchemaBuilder.prototype.validateList = function (list) {
        // ensure validation function is cached
        this.cacheListValidationFunction();
        // run validation
        var valid = this.listValidationFunction(list);
        // check if an error needs to be thrown
        if (!valid) {
            throw validationError(this.ajvList.errorsText(this.listValidationFunction.errors), this.listValidationFunction.errors);
        }
    };
    /**
     * Change the default Ajv configuration to use the given values. Any cached validation function is cleared.
     * The default validation config is { coerceTypes: false, removeAdditional: false, useDefaults: true }
     */
    SchemaBuilder.prototype.configureValidation = function (validationConfig) {
        this.validationConfig = validationConfig;
        this.clearCache();
        return this;
    };
    SchemaBuilder.prototype.clearCache = function () {
        delete this.ajvList;
        delete this.listValidationFunction;
        delete this.ajv;
        delete this.validationFunction;
    };
    Object.defineProperty(SchemaBuilder.prototype, "ajvValidationConfig", {
        get: function () {
            return __assign(__assign({}, this.defaultValidationConfig), this.validationConfig);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Explicitly cache the validation function for single objects with the current validation configuration
     */
    SchemaBuilder.prototype.cacheValidationFunction = function () {
        // prepare validation function
        if (!this.validationFunction) {
            this.ajv = new external_ajv_(this.ajvValidationConfig);
            this.validationFunction = this.ajv.compile(this.schemaObject);
        }
    };
    /**
     * Explicitly cache the validation function for list of objects with the current validation configuration
     */
    SchemaBuilder.prototype.cacheListValidationFunction = function () {
        // prepare validation function
        if (!this.listValidationFunction) {
            this.ajvList = new external_ajv_(this.ajvValidationConfig);
            this.ajvList.addSchema(this.schemaObject, "schema");
            this.listValidationFunction = this.ajvList.compile({
                type: "array",
                items: { $ref: "schema" },
                minItems: 1,
            });
        }
    };
    return SchemaBuilder;
}());

function validationError(ajvErrorsText, errorsDetails) {
    var opt = {
        name: "SerafinSchemaValidationError",
        info: {
            ajvErrors: errorsDetails,
        },
    };
    return new external_verror_(opt, "Invalid parameters: " + ajvErrorsText);
}
function throughJsonSchema(schema, action) {
    if (Array.isArray(schema)) {
        schema.forEach(function (s) {
            throughJsonSchema(s, action);
        });
    }
    else {
        var type = typeof schema;
        if (schema == null || type != "object") {
            return;
        }
        action(schema);
        if (schema.properties) {
            for (var property in schema.properties) {
                throughJsonSchema(schema.properties[property], action);
            }
        }
        if (schema.oneOf) {
            schema.oneOf.forEach(function (s) { return throughJsonSchema(s, action); });
        }
        if (schema.allOf) {
            schema.allOf.forEach(function (s) { return throughJsonSchema(s, action); });
        }
        if (schema.anyOf) {
            schema.anyOf.forEach(function (s) { return throughJsonSchema(s, action); });
        }
        if (schema.items) {
            throughJsonSchema(schema.items, action);
        }
        if (schema.not) {
            throughJsonSchema(schema.not, action);
        }
        if (schema.additionalProperties && typeof schema.additionalProperties !== "boolean") {
            throughJsonSchema(schema.additionalProperties, action);
        }
    }
    return schema;
}
/**
 * Utility method to deep clone JSON objects
 */
function cloneJSON(o) {
    if (typeof o !== "object" || o === null) {
        return o;
    }
    if (Array.isArray(o)) {
        return o.map(cloneJSON);
    }
    var r = {};
    for (var key in o) {
        r[key] = cloneJSON(o[key]);
    }
    return r;
}

// CONCATENATED MODULE: ./src/JsonSchemaType.ts
/**
 * This file contains a set of special conditional types used to transform a litteral JSON schema into the corresponding typescript type.
 */


// CONCATENATED MODULE: ./src/JsonSchema.ts


// CONCATENATED MODULE: ./src/TransformationTypes.ts
/**
 * This file contains all type transformations used by schema builder
 */


// CONCATENATED MODULE: ./src/index.ts






/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("verror");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("ajv");

/***/ })
/******/ ])));
//# sourceMappingURL=index.js.map